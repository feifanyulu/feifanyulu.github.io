<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo+butterfly搭建</title>
      <link href="/2025/02/22/hexo-butterfly/"/>
      <url>/2025/02/22/hexo-butterfly/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建hexo-butterfly"><a href="#搭建hexo-butterfly" class="headerlink" title="搭建hexo+butterfly"></a>搭建hexo+butterfly</h1><p>参考资料：<a href="https://blog.csdn.net/weixin_62726289/article/details/129930237?ops_request_misc=%7B%22request%5Fid%22%3A%22e2804188084f90fd988a0406d3e11b96%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=e2804188084f90fd988a0406d3e11b96&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-129930237-null-null.142^v101^pc_search_result_base3&amp;utm_term=butterfly配置waline上传图片&amp;spm=1018.2226.3001.4187">使用 hexo + 主题 butterfly + Github 搭建个人博客_hexo-theme-butterfly-CSDN博客</a></p><h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment">#完整命令为hexo generate,用于生成静态文件</span></span><br><span class="line">hexo s <span class="comment">#完整命令为hexo server,用于启动服务器，主要用来本地预览</span></span><br><span class="line">hexo d <span class="comment">#完整命令为hexo deploy,用于将本地文件发布到github等git仓库上</span></span><br><span class="line">hexo n “my article” <span class="comment">#完整命令为hexo new,用于新建一篇名为“my article”的文章</span></span><br></pre></td></tr></table></figure><h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="发布一篇博客"><a href="#发布一篇博客" class="headerlink" title="发布一篇博客"></a>发布一篇博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;demo&quot;</span></span><br></pre></td></tr></table></figure><p>数学符号：<a href="https://blog.csdn.net/guozhenqiang19921021/article/details/71601094?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=latex拉丁字符&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-71601094.142^v101^pc_search_result_base3&amp;spm=1018.2226.3001.4187">LaTeX 各种命令，符号_c上面一撇用chinatex怎么打-CSDN博客</a></p><h2 id="基础美化"><a href="#基础美化" class="headerlink" title="基础美化"></a>基础美化</h2><p>参考资料：<a href="https://blog.csdn.net/qq_43740362/article/details/113783074?ops_request_misc=%7B%22request%5Fid%22%3A%2240282c28307dbe873861698b149400de%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=40282c28307dbe873861698b149400de&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~time_text~default-5-113783074-null-null.142^v101^pc_search_result_base3&amp;utm_term=hexo给myself设置背景&amp;spm=1018.2226.3001.4187">Butterfly美化_butterfly-vue-CSDN博客</a></p><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><h3 id="支持博客评论"><a href="#支持博客评论" class="headerlink" title="支持博客评论"></a>支持博客评论</h3><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_45882139/article/details/129963841">Waline在Butterfly主题中的应用_butterfly配置waline-CSDN博客</a></p><p><a href="https://waline.js.org/guide/get-started/">快速上手 | Waline</a></p><ul><li>需要注意的是该步骤跳转的地址即为serverURL，需要记住这个地址</li></ul><img src="/2025/02/22/hexo-butterfly/image-20250224212312505.png" class="" title="image-20250224212312505"><ul><li>评论管理<ul><li>部署完成后，请访问 <code>&lt;serverURL&gt;/ui/register</code> 进行注册。首个注册的人会被设定成管理员。</li><li>管理员登陆后，即可看到评论管理界面。在这里可以修改、标记或删除评论。</li><li>用户也可通过评论框注册账号，登陆后会跳转到自己的档案页</li></ul></li></ul><h3 id="添加表情包"><a href="#添加表情包" class="headerlink" title="添加表情包"></a>添加表情包</h3><p>可以从该仓库选择自己喜欢的表情包类型：<a href="https://github.com/walinejs/emojis">walinejs/emojis: Emojis Repo for Waline</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\myblog\themes\butterfly\layout\includes\third-party\comments\waline.pug</span><br></pre></td></tr></table></figure><p>修改上述路径下的文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emoji: [</span><br><span class="line"><span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/alus&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;https://unpkg.com/@waline/emojis@1.1.0/qq&#x27;</span>,</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure><h3 id="评论图片"><a href="#评论图片" class="headerlink" title="评论图片"></a>评论图片</h3><p>1、在<a href="https://7bu.top">去不图床</a>购买存储容量</p><p>2、去不图床购买完成之后进入Token页面，生成Token(保存此Token，因为只显示一次。)</p><p>3、修改waline.pug文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\myblog\themes\butterfly\layout\includes\third-party\comments\waline.pug</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    const waline = Fn(&#123;</span><br><span class="line">      el: el.querySelector(<span class="string">&#x27;#waline-wrap&#x27;</span>),</span><br><span class="line">      serverURL: <span class="string">&#x27;https://feifanyulu-waline.vercel.app&#x27;</span>,//</span><br><span class="line">      emoji: [</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/alus&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.1.0/qq&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/bmoji&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/tieba&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/weibo&#x27;</span>,</span><br><span class="line">      ],</span><br><span class="line">      pageview: !&#123;lazyload ? <span class="literal">false</span> : pageview&#125;,</span><br><span class="line">      dark: <span class="string">&#x27;html[data-theme=&quot;dark&quot;]&#x27;</span>,</span><br><span class="line">      comment: !&#123;lazyload ? <span class="literal">false</span> : count&#125;,</span><br><span class="line">      </span><br><span class="line">//-----------------------在文件中添加如下部分------------------------------------//</span><br><span class="line">      imageUploader: (file) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (!file) &#123;  </span><br><span class="line">            throw new Error(<span class="string">&#x27;No file provided&#x27;</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="built_in">let</span> formData = new FormData();</span><br><span class="line">          <span class="built_in">let</span> headers = new Headers();</span><br><span class="line">          formData.append(<span class="string">&#x27;file&#x27;</span>, file);</span><br><span class="line">          </span><br><span class="line">          headers.set(<span class="string">&#x27;Authorization&#x27;</span>, <span class="string">&#x27;API TOKEN&#x27;</span>);  // API TOKEN需要改成第二步复制的token，去不给的token是1234|xxxx，前面的数字和竖杠不需要，加上Bearer 变成Bearer xxxxx才能认证通过</span><br><span class="line">          headers.set(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="built_in">return</span> fetch(<span class="string">&#x27;https://7bu.top/api/v1/upload&#x27;</span>, &#123;    // 去不图床的API就是此链接，如果你用的其他图床就改成其他的</span><br><span class="line">            method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            headers: headers,</span><br><span class="line">            body: formData,</span><br><span class="line">            mode: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">          &#125;)</span><br><span class="line">            .<span class="keyword">then</span>((resp) =&gt; resp.json())</span><br><span class="line">            .<span class="keyword">then</span>((resp) =&gt; resp.data.links.url);</span><br><span class="line">        &#125;,</span><br><span class="line">//----------------------------------------------------------------------------//</span><br><span class="line">      ...option,</span><br><span class="line">      path: isShuoshuo ? path : (option &amp;&amp; option.path) || path</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_40673755/article/details/140539730?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-140539730-blog-129963841.235^v43^control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-140539730-blog-129963841.235^v43^control&amp;utm_relevant_index=5">为Hexo添加评论系统Waline并配置图床_hexo waline-CSDN博客</a></p><h1 id="遇见的问题"><a href="#遇见的问题" class="headerlink" title="遇见的问题"></a>遇见的问题</h1><h2 id="md格式的博文上传后图片无法显示"><a href="#md格式的博文上传后图片无法显示" class="headerlink" title="md格式的博文上传后图片无法显示"></a>md格式的博文上传后图片无法显示</h2><p>1、将 _config.yml 文件中的 post_asset_folder 选项设为 true；(该操作的目的就是在使用<code>hexo new xxx</code>指令新建md文档博文时，在相同的/source/posts路径下同步创建一个相同名字的<code>xxx</code>文件夹，而<code>xxx</code>文件夹就是用来存放新建md文档里的图片的)</p><p>2、使用typora编辑md格式的博文，需要对typora的设置—&gt;偏好设置中进行修改，如下：(这样我们粘贴图片到md文档的时候，typora会自动把图片再复制一份到我们上面创建的同名文件夹下)</p><img src="/2025/02/22/hexo-butterfly/image-20250224213647018.png" class="" title="image-20250224213647018"><p>参考资料：<a href="https://blog.csdn.net/lengcs/article/details/143816877?ops_request_misc=%7B%22request%5Fid%22%3A%2239167e82ce3160fc47f69925ea7bb820%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=39167e82ce3160fc47f69925ea7bb820&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-13-143816877-null-null.142^v101^pc_search_result_base3&amp;utm_term=hexo md插入图片&amp;spm=1018.2226.3001.4187">[2024] hexo图片无法加载究极解决方案_hexo图片显示不出来-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> ToolGuide </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>centos7.3部署lustre2.10.8</title>
      <link href="/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/"/>
      <url>/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><a href="http://lustrefs.cn/wp-content/uploads/2023/03/Lustre_Manual_cn.pdf">Lustre_Manual_cn.pdf</a></p><p>Lustre中的角色：</p><ol><li><strong>管理服务器（Management Server, MGS）：</strong></li></ol><p>​    ● 管理整个文件系统的元信息和配置。</p><p>​    ● 硬件要求：高性能 CPU、充足的内存和可靠存储设备。</p><ol><li><strong>元数据服务器（Metadata Server, MDS）：</strong></li></ol><p>​    ● 存储文件系统的元数据（如文件名、目录结构等）。</p><p>​    ● 通常与元数据目标（Metadata Target, MDT）一起部署在 MDS 上。</p><ol><li><strong>对象存储服务器（Object Storage Server, OSS）：</strong></li></ol><p>​    ● 存储文件数据。</p><p>​    ● 每个 OSS 管理一个或多个对象存储目标（Object Storage Target, OST）。</p><ol><li><strong>客户端：</strong></li></ol><p>​    ● 连接并访问 Lustre 文件系统的计算节点</p><p><a href="https://www.hikunpeng.com/document/detail/zh/kunpengsdss/ecosystemEnable/Lustre/openmind_kunpenglustre_04_0002.html">环境要求-Lustre 2.13.0 部署指南（CentOS 8.0）-Lustre-开源使能-开发文档-鲲鹏社区</a>)</p><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><p>参考文档:</p><p><a href="https://note.youdao.com/ynoteshare/index.html?id=113224210bf5120b2731ae9e0af5ebb4&amp;type=note&amp;_time=1734593758030">Lustre 2.10安装.note</a></p><p><a href="https://blog.csdn.net/spring_color/article/details/79301167?ops_request_misc=%7B%22request%5Fid%22%3A%22d9945c8131134fab2ed7eff447d79e82%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=d9945c8131134fab2ed7eff447d79e82&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-79301167-null-null.142^v100^pc_search_result_base3&amp;utm_term=Lustre部署·centos7&amp;spm=1018.2226.3001.4187">CentOS-7 安装Lustre-2.10.1文件系统_centos7安装lustre-CSDN博客</a></p><div class="table-container"><table><thead><tr><th>节点名</th><th>节点IP</th><th>节点角色</th><th>软件版本</th></tr></thead><tbody><tr><td>cn17538</td><td>10.182.190.3</td><td>MDS、MDT、OST</td><td>系统版本：centos7.3</td></tr><tr><td>cn17539</td><td>10.182.190.4</td><td>MDT、OST</td><td>软件版本：7.2.4-el7</td></tr><tr><td>cn17540</td><td>10.182.190.5</td><td>Client</td></tr></tbody></table></div><h3 id="简单配置Linux"><a href="#简单配置Linux" class="headerlink" title="简单配置Linux"></a>简单配置Linux</h3><p>1、更新yum源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum clean all</span><br><span class="line">$ yum makecache</span><br><span class="line">$ yum update</span><br></pre></td></tr></table></figure><p>2、 安装基础包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum groupinstall <span class="string">&quot;Development Tools&quot;</span> -y</span><br><span class="line">$ yum install epel-release quilt libselinux-devel python-docutils xmlto asciidoc elfutils-libelf-devel elfutils-devel zlib-devel rng-tools binutils-devel python-devel sg3_utils newt-devel perl-ExtUtils-Embed audit-libs-devel lsof hmaccalc -y</span><br></pre></td></tr></table></figure><p>3、关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld.service</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure><h3 id="构建本地Lustre-repo库"><a href="#构建本地Lustre-repo库" class="headerlink" title="构建本地Lustre repo库"></a>构建本地Lustre repo库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/yum.repos.d/lustre.repo</span><br></pre></td></tr></table></figure><p>在lustre.repo里写入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[lustre-server]</span><br><span class="line">name=lustre-server</span><br><span class="line">baseurl=https://downloads.whamcloud.com/public/lustre/latest-2.10-release/el7/server</span><br><span class="line"><span class="comment"># exclude=*debuginfo*</span></span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">[lustre-client]</span><br><span class="line">name=lustre-client</span><br><span class="line">baseurl=https://downloads.whamcloud.com/public/lustre/latest-2.10-release/el7/client</span><br><span class="line"><span class="comment"># exclude=*debuginfo*</span></span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">[e2fsprogs-wc]</span><br><span class="line">name=e2fsprogs-wc</span><br><span class="line">baseurl=https://downloads.whamcloud.com/public/e2fsprogs/latest/el7</span><br><span class="line"><span class="comment"># exclude=*debuginfo*</span></span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>更新源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum clean all </span><br><span class="line">$ yum makecache</span><br></pre></td></tr></table></figure><p>参考文档出现如下出现问题：</p><img src="/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/image-20250225215515963.png" class="" title="image-20250225215515963"><p>解决问题：参考文档中这一部分操作写了一堆，我也看不懂，不知道什么原因，我直接在/etc/yum.repos.d中创建了lustre.repo文件，并更新了yum源，似乎没什么问题</p><h2 id="服务节点安装（MDS、OSS）"><a href="#服务节点安装（MDS、OSS）" class="headerlink" title="服务节点安装（MDS、OSS）"></a>服务节点安装（MDS、OSS）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ yum --nogpgcheck --disablerepo=* --enablerepo=e2fsprogs-wc install e2fsprogs -y</span><br><span class="line">$ yum -y install epel-release</span><br><span class="line">$ yum install http://download.zfsonlinux.org/epel/zfs-release.el7_3.noarch.rpm -y</span><br><span class="line">$ yum upgrade linux-firmware dracut -y <span class="comment"># 升级冲突包</span></span><br><span class="line">$ yum upgrade xfsprogs kmod kexec-tools -y <span class="comment"># 升级冲突包</span></span><br><span class="line">$ yum install pciutils -y</span><br><span class="line">$ yum --nogpgcheck --disablerepo=base,extras,updates --enablerepo=lustre-server install kernel kernel-devel kernel-headers kernel-tools kernel-tools-libs kernel-tools-libs-devel -y</span><br><span class="line">$ reboot</span><br><span class="line">$ yum --nogpgcheck --enablerepo=lustre-server install kmod-lustre-osd-ldiskfs lustre-dkms lustre-osd-ldiskfs-mount lustre lustre-resource-agents zfs lustre-osd-zfs-mount -y</span><br><span class="line"></span><br><span class="line">加载 ZFS 文件系统的内核模块</span><br><span class="line">$ modprobe -v zfs</span><br><span class="line">加载 Lustre 文件系统的内核模块</span><br><span class="line">$ modprobe -v lustre</span><br></pre></td></tr></table></figure><p>服务节点安装的是2.10.8版本，客户端安装2.10.8版本时发现，centos默认的内核不支持客户端安装2.10.8版本，所以客户端安装的是2.10.1版本。</p><h1 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a><strong>客户端安装</strong></h1><p>最好不要和MDS和ODS安装在一个节点上，会出现内核不兼容的问题，如果出现安装的客户端与默认的系统内核不兼容的问题，可以尝试更换系统中其他的内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum install kernel kernel-devel kernel-headers kernel-abi-whitelists kernel-tools kernel-tools-libs kernel-tools-libs-devel -y</span><br><span class="line">$ reboot</span><br><span class="line">$ yum install epel-release -y</span><br><span class="line">$ yum --nogpgcheck --enablerepo=lustre-client install lustre-client-dkms lustre-client kmod-lustre-client -y</span><br></pre></td></tr></table></figure><p>切换内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看当前系统可用内核</span><br><span class="line">$ <span class="built_in">sudo</span> awk -F\&#x27; <span class="string">&#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27;</span> /etc/grub2.cfg</span><br><span class="line">选择输出的内核编号</span><br><span class="line">$  <span class="built_in">sudo</span> grub2-set-default <span class="string">&#x27;1&#x27;</span></span><br><span class="line">$ reboot</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h1><p>​     Lustre是基于内核的分布式文件系统，而不是像其它一些用户态的分布式文件系统那样直接建立在ext3或者是ext4之上。Lustre需要对磁盘进行格式化，并且在格式化的过程中进行参数配置。</p><p>​    在 Lustre 中，MGS（Management Server） 是一个集中式的元数据服务，它负责管理整个 Lustre 文件系统的元数据。MGS 通常只在第一个 MDT 节点上配置，并且该节点会作为主 MDT 来管理所有的元数据操作。一旦配置了 MGS，Lustre 文件系统的所有 MDT节点会通过网络连接到该 MGS。因为 MGS 是唯一的，它的作用是服务所有 MDT 节点（无论你有多少个 MDT 节点）</p><h3 id="配置MDT"><a href="#配置MDT" class="headerlink" title="配置MDT"></a>配置MDT</h3><p>通过—index来对每个MDT进行标识</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、配置第一个MDS</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgs --mdt --index=0 /dev/nvme0n1p3</span><br><span class="line"> $ <span class="built_in">mkdir</span> /mnt/lustre/mdt</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p3 /mnt/lustre/mdt</span><br><span class="line"></span><br><span class="line">2、配置第二个MDS</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgsnode=10.182.190.3@tcp0 --mdt --index=1 /dev/nvme0n1p3</span><br><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre/mdt</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p3 /mnt/lustre/mdt</span><br><span class="line"> </span><br><span class="line">参数解释： </span><br><span class="line">fsname指定的是创建lustre时的文件系统名 </span><br><span class="line">mgs指定该机器为元数据服务器，即该机器为mds </span><br><span class="line">mdt指定/dev/sdb为元数据实际数据存储位置 </span><br><span class="line">至于index则指定该mgs的索引号，mgs可以设置主备模式，但mdt需要在主备mds之间共享 </span><br></pre></td></tr></table></figure><h3 id="配置OST"><a href="#配置OST" class="headerlink" title="配置OST"></a>配置OST</h3><p>通过—index来对每个OST进行标识</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、配置第一个OST</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgsnode=10.182.190.3@tcp0 --ost --index=0 /dev/nvme0n1p2</span><br><span class="line">查看是否格式化成功</span><br><span class="line">$ <span class="built_in">sudo</span> lsblk -f</span><br><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre/ost</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p2 /mnt/lustre/ost</span><br><span class="line"></span><br><span class="line">2、配置第二个OST</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgsnode=10.182.190.3@tcp0 --ost --index=1 /dev/nvme0n1p2</span><br><span class="line">查看是否格式化成功</span><br><span class="line">$ <span class="built_in">sudo</span> lsblk -f</span><br><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre/ost</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p2 /mnt/lustre/ost</span><br></pre></td></tr></table></figure><h3 id="配置Client"><a href="#配置Client" class="headerlink" title="配置Client"></a>配置Client</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre</span><br><span class="line">$ mount -t lustre 10.182.190.3@tcp:/lustrefs /mnt/lustre</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ToolGuide </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/2025/02/19/Compilation-Principle/"/>
      <url>/2025/02/19/Compilation-Principle/</url>
      
        <content type="html"><![CDATA[<p>​    程序设计语言是向人以及计算机描述计算过程的记号。例如我们所知道的这个世界依赖于程序设计语言，因为在所有计算机上运行的所有软件都是用某种程序设计语言编写的。但是，在一个程序可以运行之前，它首先需要被翻译成一种能够被计算机执行的形式，完成这项翻译工作的软件系统就是编译器。编译器可以将某种语言(源语言)编写的程序翻译成一个等价的用另外一种语言编写的程序。</p><p>​    编译器能够把源程序映射为语义上等价的目标程序，这个过程可以由两部分组成: 分析部分和综合部分；</p><ul><li>分析部分(前端)：把源程序分解成为多个组成要素，并在这些要素之上加上语法结构。然后使用这个结构来创建该源程序的一个中间表示。如果分析部分检查出源程序没有按照正确的语法构成，或者语义上不一致，它就必须提供有用的信息，使得用户可以按此进行改正。分析部分还会收集有关源程序的信息，并把信息存放在一个称为符号表的数据结构中。符号表将和中间表示形式一起传送给综合部分。</li><li>综合部分(后端)：根据中间表示和符号表中的信息来构造用户期待的目标程序。</li></ul><p>编译过程中顺序的执行了一组步骤。每个步骤把源程序的一种表示方式转换为另一种表示方式。如下图所示</p><img src="/2025/02/19/Compilation-Principle/image-20250222145903286.png" class="" title="image-20250222145903286"><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>源程序—&gt; <strong>词法分析器</strong> —&gt;记号流(token)—&gt; <strong>语法分析器</strong> —&gt;抽象语法树—&gt; <strong>语义分析器</strong> —&gt;中间表示IR</p><img src="/2025/02/19/Compilation-Principle/image-20250222124616749.png" class="" title="image-20250222124616749"><h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p>两种实现方式：</p><ul><li>手动编码，GCC、LLVM，转移图算法</li><li>词法生成器自动生成器(lex/flex/jlex)</li></ul><p>RE—&gt;NFA—&gt;DFA—&gt;词法分析器代码<br>中间算法：Thompson算法—子集构造算法—Hopcroft最小化算法</p><h3 id="正则表达式RE"><a href="#正则表达式RE" class="headerlink" title="正则表达式RE"></a>正则表达式RE</h3><p>声明式规范(正则表达式)—&gt;词法分析器<br>对于给定的字符集 $\Sigma = {c1,c2,…,cn}$<br>归纳定义：</p><ul><li>空串是正则表达式</li><li>对于任意的 <script type="math/tex">c\in\Sigma</script>，c是正则表达式</li><li>如果M和N是正则表达式，则以下也是正则表达式<ul><li>选择  M|N = {M, N}</li><li>连接  MM = {mn| m <script type="math/tex">\in</script> M, n <script type="math/tex">\in</script> N }</li><li>闭包  M* = { $\varepsilon$, M, MM, MMM, … }</li></ul></li></ul><h3 id="有限状态自动机FA"><a href="#有限状态自动机FA" class="headerlink" title="有限状态自动机FA"></a>有限状态自动机FA</h3><p>输入的字符串—&gt;FA—&gt;{yes, no} 什么样的串可以被接受</p><ul><li>确定状态有限自动机DFA<ul><li>对任意的字符，最多有一个状态可以转移</li></ul></li><li>非确定状态有限自动机NFA<ul><li>对任意的字符，有多个状态可以转移</li></ul></li></ul><h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>记号流(token)—&gt; <strong>语法分析器</strong> (语言的语法规则) —&gt; 语法树<br>语法规则：<br>上下文无关文法的定义：</p><ul><li>上下文无关文法(简称 <strong>文法</strong> )由终结符号、非终结符号、一个开始符号和一组产生式组成</li><li>终结符号是组成串的基本符号</li><li>非终结符号是表示串的集合的语法变量</li><li>某个非终结符号被指定为开始符号，这个符号表示的串集合就是这个文法生成的语言。按照惯例，首先列出来开始符号的产生式。</li><li>一个文法的产生式描述了将终结符号和非终结符号组合成串的方法。每个产生式由下列形式组成：<blockquote><p>非终结符号 —→ 零个或者多个终结符号与非终结符号组成<br>selection_statement<br>: IF ‘(‘ expression ‘)’ statement<br>| IF ‘(‘ expression ‘)’ statement ELSE statement;<br>|<br>;</p></blockquote></li></ul><p>语法分析树：过滤掉了推导过程中对非终结符号应用产生式的顺序。语法分析树的每个内部节点表示一个产生式的应用。该内部节点表示一个产生式的应用。该内部节点的标号是此产生式头中的非终结符号A；这个节点的子节点的标号从左到右组成了在推导过程中替换这个A的产生式体。</p><p>二义性：如果一个文法可以为某个句子生成多棵语法分析树，那么它就是二义性的；换句话说，二义性文法就是对同一个句子有多个最左推导或多个最右推导的文法。<br>解决方法：文法的重写</p><p>语法分析器的实现方式</p><ul><li>手工分析—递归下降分析器</li><li>自动生成器—LL(1)、LR(1)</li></ul><h3 id="自顶向下分析：从开始符号出发推导句子"><a href="#自顶向下分析：从开始符号出发推导句子" class="headerlink" title="自顶向下分析：从开始符号出发推导句子"></a>自顶向下分析：从开始符号出发推导句子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tokens[];</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">stack = [s];</span><br><span class="line"><span class="keyword">while</span> ( stack != [] )</span><br><span class="line">    <span class="keyword">if</span> ( stack[top] is a terminal t)</span><br><span class="line">        <span class="keyword">if</span> ( t==tokens[i++] )</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">backtrack</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( stack[top] is a nonterminal T )</span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">push</span>( the next right hand side of T );</span><br></pre></td></tr></table></figure><p>需要通道回溯，给分析效率带来问题；实际上编译器必须高效，需要线性时间的算法，因此引出递归下降分析和LL(1)分析；</p><p>递归下降分析算法(预测分析)</p><ul><li>每个非终结符构造一个分析函数；</li><li>用前看符号指导产生式规则的选择。</li></ul><p>自动生成<br>声明式的规范—&gt;自动生成器(antlr:LL(1)、YACC(Unix)、bison(linux))—&gt;语法分析器<br>LL(1)分析算法</p><ul><li>从左(L)向右读入程序，最左(L)推导，采用一个(1)前看符号<ul><li>分析高效(线性时间)</li><li>错误定位和诊断信息准确</li><li>有很多开源或商业的生成工具(antlr)</li></ul></li><li>基本思想：表驱动的分析算法</li><li>缺点  <ul><li>能分析的文法类型受限</li><li>往往需要文法的改写</li></ul></li></ul><h3 id="自底向上分析"><a href="#自底向上分析" class="headerlink" title="自底向上分析"></a>自底向上分析</h3><p>LR分析算法(移进-规约算法)</p><ul><li>算法运行高效，有现成的工具可用</li><li>目前最广泛的一类语法分析器的自动生成器(YACC,bison,CUP,C#yacc等)中采用的算法</li><li>移进 一个记号到栈顶上，或者</li><li>规约 栈顶上的n个符号(某产生式的右部)到左部的非终结符<ul><li>对产生式A —&gt; $\beta 1…\beta n$<ul><li>如果 $\beta n…\beta 1$在栈顶上，则弹出 $\beta n…\beta 1$ ，压入A</li></ul></li></ul></li><li>表驱动的LR分析器架构<br>点记号：为了方便标记语法分析器已经读入了多少输入，我们可以引入一个点记号；</li></ul><p>LR(0)分析算法</p><ul><li>从左(L)向右读入程序，最右(R)推导，不用前看符号来决定式的选择(0个前看符号)<ul><li>优点：容易实现</li><li>缺点：能分析的文法有限</li></ul></li></ul><p>SLR分析算法</p><ul><li>和LR(0)分析算法基本步骤相同</li><li>仅区别于对归约的处理<ul><li>对于状态i上的项目X-&gt; $\alpha ·$, 仅对y $\in$ FOLLOW(X)添加ACTION[i,y]</li></ul></li></ul><p>LR(1)分析算法</p><ul><li>基于LR(0),通过进一步判断一个前看符号，来决定是否执行规约动作<ul><li>X—&gt; $\alpha ·$归约，当且仅当y $\in$ FOLLOW(X)</li></ul></li><li>优点<ul><li>有可能减少需要归约的情况</li><li>有可能去除需要递进-归约冲突</li></ul></li><li>缺点<ul><li>仍然有冲突出现的可能</li></ul></li></ul><p>对二义性文法的处理</p><ul><li>二义性文法无法使用LR分析算法分析</li><li>有几类二义性文法很容易理解：优先级、结合性、悬空else</li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>YACC是Yet Another Compiler-Compiler缩写，在1975年首先在此基础上做了改进：例如GNU Bison，并移植到其他语言上<br>Yacc架构</p><blockquote><p>用户代码和yacc声明：可以再接下来的部分使用<br>%%<br>语法规则：上下文无关文法<br>%%<br>用户代码：用户提供的代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">yylex</span><span class="params">()</span></span>;<span class="comment">//词法分析器的接口</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%left <span class="string">&#x27;+&#x27;</span></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">exp : n</span><br><span class="line">    | exp + exp</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">n: <span class="string">&#x27;1&#x27;</span>| <span class="string">&#x27;2&#x27;</span> | <span class="string">&#x27;3&#x27;</span> |;</span><br><span class="line">%%</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">yylex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">char</span>* s)</span></span>&#123;</span><br><span class="line">   <span class="built_in">fprintf</span> (stderr, <span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">yyparse</span>(); <span class="comment">// 语法分析器的驱动函数；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法制导的翻译"><a href="#语法制导的翻译" class="headerlink" title="语法制导的翻译"></a>语法制导的翻译</h3><p>编译器在做语法分析的过程中，除了回答程序语法是否合法外，还必须完成后续工作</p><ul><li>可能得工作(包括但不限于)：类型检查、目标代码生成、中间代码生成。这些后续的工作一般可通过语法制导的翻译完成；</li><li>给每条产生式规则附加一条语义动作(一个代码片段)</li><li>语义动作产生式”归约”时执行，即由右部的值计算左部的值，以自底向上的技术为例进行讨论</li></ul><h3 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h3><p><style>.vqocyvpikmxn{zoom: 40%;}</style><img src="/2025/02/19/Compilation-Principle/image.png" class="vqocyvpikmxn" alt="image"><br>对于表达书而言，编译器只需要知道运算符和运算符(优先级、结合性等已经在语法分析部分处理掉了)。对于语句、函数等语言其他构造而言也一样(例如编译器不关心赋值符号是=还是:=或其他)s</p><ul><li>具体语法是语法分析器使用的语法<ul><li>必须适合于语法分析，如各种分隔符、消除左递归、提取左公因子等；</li></ul></li><li>抽象语法是用来表达语法结构的内部表示<ul><li>现代编译器一般都采用 <strong>抽象语法作为前端(词法语法分析)和后端(代码生成)的接口</strong><ul><li>程序一旦被转换为抽象语法树，则源代码即被丢弃，后续阶段只处理抽象语法树</li><li>所以抽象语法书必须编码足够多的源代码信息，例如：必须编码每个语法结构在源代码中的位置(文件、行号、列号等)</li></ul></li><li>为了定义抽象语法树，编译器需要使用实现语言来定义一组数据结构</li></ul></li></ul><h2 id="语义分析器"><a href="#语义分析器" class="headerlink" title="语义分析器"></a>语义分析器</h2><p>语义分析也称为类型检查、<strong>上下文相关分析</strong>，负责检查程序(抽象语法树)的上下文相关的属性:例如，变量使用前先进行声明、每个表达式都有合适的类型、函数调用和函数的定义一致。</p><p>抽象语法树—&gt;语义分析器(根据程序语言的语义进行判断)—&gt;中间代码</p><p>语义检查</p><p>符号表: 用来存储程序中的变量相关信息(类型、作用域、访问控制信息，处理名字空间)、应为程序中的变量规模会风大，所以必须非常高效，可以使用哈希表(节省时间、O(1)时间)、红黑树(节省空间、O(lgN)时间)等数据结构来实现。</p><p>语义分析：类型相容性、错误诊断、代码翻译</p><h1 id="中间端和后端"><a href="#中间端和后端" class="headerlink" title="中间端和后端"></a>中间端和后端</h1><p>抽象语法树—&gt;代码生成(翻译1—&gt;中间表示1—&gt;翻译2—&gt;中间表示2—&gt;更多的翻译和中间表示)—&gt;汇编</p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>负责把源程序翻译成”目标机器”上的代码，两个重要任务:</p><ul><li>给源程序的数据分配计算资源<ul><li>源程序的数据：全局变量、局部变量、动态分配等</li><li>机器计算资源：寄存器、数据区、代码区、栈区、堆区</li><li>根据程序的特点和编译器的设计目标，合理的为数据分配计算机资源，例如：变量放在内存里还是寄存器里？</li></ul></li><li>给源程序的代码选择指令<ul><li>源程序的代码：表达式运算、语句、函数等</li><li>机器指令：算术运算、比较、跳转、函数调用返回</li><li>用机器指令实现高层代码的语义：等价性、对机器指令集体系结构(ISA的熟悉)</li></ul></li></ul><p>两种不同的ISA上的代码生成技术</p><ul><li>栈计算机stack<ul><li>历史：在上世纪70年代有很多的栈式计算机，但是因为效率低下已经逐渐退出历史舞台；</li><li>给栈式计算机生产代码是最容易的；</li><li>仍然有很多栈式的虚拟机：Pascal P code、java virtual machine(JVM)…..</li></ul></li><li>寄存器计算机Reg<ul><li>寄存器计算机是目前最流行的机器体系结构之一，效率很高，机器体系结构规整</li><li>机器基于寄存器架构：<ul><li>经典的有16、32或更多个寄存器，所有操作都在寄存器中进行</li><li>访存都通过load/store进行，内存不能直接运算</li></ul></li></ul></li></ul><h2 id="中间代码的地位和作用"><a href="#中间代码的地位和作用" class="headerlink" title="中间代码的地位和作用"></a>中间代码的地位和作用</h2><p>为什么划分不同的中间表示？</p><p>编译器工程上的考虑</p><ul><li>阶段划分：把整个编译过程划分为不同的阶段</li><li>任务分解：每个阶段只处理翻译过程的一个步骤</li><li>代码工程：代码更容易实现、出错、维护和演进</li></ul><p>程序分析和代码优化的需求：两者都和程序的中间表示密切相关，许多优化在特定的中间表示上才可以或才容易进行；</p><p>现代编译器中几种常见的重要中间表示(Intermediate Representation，IR)：三地址码、控制流图、静态单赋值形式；</p><p>在中间表示上做程序分析的理论和技术：控制流分析、数据流分析</p><ul><li><h5 id="三地址码"><a href="#三地址码" class="headerlink" title="三地址码"></a>三地址码</h5><ul><li><p><strong>每条指令有三项操作数</strong>，因此叫做三地址码。每条指令通常会有一个目标地址（存储结果的变量或临时变量），以及两个源地址（操作数）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y op z</span><br></pre></td></tr></table></figure></li><li><p>给每个中间变量和计算结果命名后没有复合表达式</p></li><li><p>只有最基本的控制流，没有各种控制结构(if、do、for…)，只有goto、call等</p></li><li><p>所以三地址码可以看成是抽象的指令集，可以看成是一个通用的RISC</p></li><li><p>程序的控制流信息是隐式的，可以做进一步的控制流分析</p><p><style>.fxumsrvckgwa{zoom:80%;}</style><img src="/2025/02/19/Compilation-Principle/image-20250221171039051.png" class="fxumsrvckgwa" alt="image-20250221171039051"></p></li></ul></li><li><h5 id="控制流分析"><a href="#控制流分析" class="headerlink" title="控制流分析"></a>控制流分析</h5><ul><li><p>是更加精细的三地址码</p></li><li><p>程序的控制流图表示带来了很多好处</p><ul><li>控制流分析：对于很多程序分析来说，程序的内部结构很重要；经典问题：程序中是否存在循环？</li><li>可以进一步进行其他分析：例如数据流分析；经典问题：程序第5行的变量x可能的值是什么？</li></ul><img src="/2025/02/19/Compilation-Principle/image-20250221205441500.png" class="" title="image-20250221205441500"></li><li><p>现代编译器的早期阶段就会倾向于做控制流分析，方便后续阶段的分析</p></li><li><p>基本块：是一个语句的序列，从第一条执行到最后一条，不能从中间进入和退出(即跳转指令只能出现在最后)</p></li><li><p>控制流图：控制流图是一个有向图G=(V,E)；节点V是基本块，边E是基本块之间的跳转关系</p><img src="/2025/02/19/Compilation-Principle/image-20250221193740043.png" class="" title="image-20250221193740043"></li><li><p>可以直接从抽象语法树生成：如果高层语言具有特别规整控制流结构的话较容易；也可以先生成三地址码，然后继续生成控制流图：</p><ul><li>对于像C这样的语言更加合适，包含像goto这样的非结构化的控制流语句；</li><li>更加通用(阶段划分)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List_t stms;               <span class="comment">// 三地址码中所有语句</span></span><br><span class="line">List_t blocks = &#123;&#125;；       <span class="comment">//控制流图中的所有基本块</span></span><br><span class="line">Block_t b = <span class="built_in">Block_fresh</span>();   <span class="comment">//一个初始的空的基本块</span></span><br><span class="line"><span class="built_in">scan_stms</span>()</span><br><span class="line">    foreach(s in stms)</span><br><span class="line">    <span class="keyword">if</span> (s is <span class="string">&quot;Label L&quot;</span>)    <span class="comment">// s是标号</span></span><br><span class="line">            b.label = L;</span><br><span class="line"><span class="keyword">else</span> (s is some jump)  <span class="comment">//s是跳转</span></span><br><span class="line">            b.j = s;</span><br><span class="line">blocks U= &#123;b&#125;;</span><br><span class="line">b = <span class="built_in">Block_fresh</span>();</span><br><span class="line"><span class="keyword">else</span>                 <span class="comment">// s是普通指令</span></span><br><span class="line">            b.stms U= &#123;s&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>标准的图论算法都可以用在控制流图的操作上：各种遍历算法、生成树、必经节点结构等等；</li><li>图节点的顺序有重要的应用：拓扑序、逆拓扑序、近似拓扑序等等；</li></ul><ul><li><h5 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h5><ul><li>常量传播优化</li><li>通过对程序代码进行静态分析，得到关于程序数据相关的保守信息，必须保证程序分析的结果是安全的</li><li>根据优化的目标不同，需要进行的数据流分析也不同<ul><li><strong>到达定义分析</strong>：对每个变量的使用点，有哪些定义可以到达？(即该变量的值是在哪儿赋值的)<ul><li>数据流方程</li></ul></li><li><strong>活性分析</strong>：在代码生成的讨论中，机器只有有限多个寄存器，寄存器分配优化需要进行活性分析</li></ul></li></ul></li></ul><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>代码优化是对被优化的程序进行的一种语义保持(程序的可观察行为不能改变)的变换，变换的目的是让程序能够比变换前更小、更快、cache行为更好、更节能等等；</p><h5 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h5><ul><li><p>一般在抽象语法树阶段做优化</p></li><li><p>局部的、流不敏感的</p></li><li><p>常量折叠、代数优化、死代码删除等</p><ul><li><p>常量折叠：在编译期间计算表达式的值，可以在整型、布尔型、浮点型等数据类型上进行；容易实现、可以在语法树或者中间表示上进行，通常被实现成公共子函数被其他优化调用；</p><blockquote><p>例如：a=3+5 ==&gt; a=8</p><p>例如：if(true&amp;&amp;false) ==&gt;if(false)</p><p>必须要很小心遵守语言的语义，例如：考虑溢出或异常  oxffffffff+1==&gt;0 ???</p></blockquote></li><li><p>代数化简：利用代数系统的性质对程序进行化简</p><blockquote><p>示例：</p><p>a = 0+b ==&gt; a = b</p><p>a = 1*b ==&gt; a = b</p><p>2*a ==&gt; a + a          （强度削弱）</p><p>2*a ==&gt; a&lt;&lt;1             (强度削弱)</p><p>同样必须非常仔细的处理语义，例如：(i - j) + (i - j) ==&gt; i + i - j - j</p></blockquote></li><li><p>死代码(不可达代码)删除：静态移除程序中不可执行的代码</p><blockquote><p>示例:</p><p>if (false)</p><p>​       s1;</p><p>else s2;       ==&gt; s2;</p><p>在控制流图中也可以进行这些优化，但在早期做这些优化可以简单中后端</p></blockquote></li></ul></li></ul><h5 id="中期优化"><a href="#中期优化" class="headerlink" title="中期优化"></a>中期优化</h5><ul><li><p>在中间表示上进行代码优化</p></li><li><p>全局的、流敏感的</p></li><li><p>依赖于具体所使用的中间表示：</p><ul><li><p>控制流图(CFG)、控制依赖图(CDG)、静态单赋值形式(SSA)、后续传递风格(CPS)等</p></li><li><p>共同的特点是需要进行程序分析，优化是全局进行的，而不是局部，通用的模式是：程序分析—&gt;程序重写</p></li><li><p>优化的一般模式: </p><img src="/2025/02/19/Compilation-Principle/image-20250222141611890.png" class="" title="image-20250222141611890"></li></ul></li><li><p>常量传播、拷贝传播、死代码删除、公共字表达式删除等</p><ul><li><p>常量传播：先进行到达定义分析,例如x=1,y=2,z=x+y —&gt; x=1,y=2,z=3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量传播算法</span></span><br><span class="line"><span class="built_in">const_prop</span>(Prog_t p)</span><br><span class="line">    <span class="comment">//第一个：程序分析</span></span><br><span class="line">    <span class="built_in">reaching_definition</span>(p)</span><br><span class="line">    <span class="comment">//第二步：程序改写</span></span><br><span class="line">    foreach(stm s in p: y = x1,...,xn)</span><br><span class="line">    foreach(use of xi in s)</span><br><span class="line">    <span class="keyword">if</span>(the reaching def of xi is unique: xi = n )</span><br><span class="line">                y = x1,...,xi<span class="number">-1</span>,n,xi<span class="number">+1</span>,...,xn</span><br></pre></td></tr></table></figure></li><li><p>拷贝传播: 例如: x=y ;a=x —&gt; a=y</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量传播算法</span></span><br><span class="line"><span class="built_in">const_prop</span>(Prog_t p)</span><br><span class="line">    <span class="comment">//第一个：程序分析</span></span><br><span class="line">    <span class="built_in">reaching_definition</span>(p)</span><br><span class="line">    <span class="comment">//第二步：程序改写</span></span><br><span class="line">    foreach(stm s in p: y = x1,...,xn)</span><br><span class="line">    foreach(use of xi in s)</span><br><span class="line">    <span class="keyword">if</span>(the reaching def of xi is unique: xi = z )</span><br><span class="line">                y = x1,...,xi<span class="number">-1</span>,z,xi<span class="number">+1</span>,...,xn</span><br></pre></td></tr></table></figure></li><li><p>死代码删除：需要进行活性分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//死代码删除算法</span></span><br><span class="line"><span class="built_in">dead_code</span>(Prog_t p)</span><br><span class="line">    <span class="comment">//第一步：程序分析</span></span><br><span class="line">    <span class="built_in">liveness_analysis</span>(p);</span><br><span class="line"><span class="comment">//第二步：程序改写</span></span><br><span class="line">foreach(stm s in p:y = ...)</span><br><span class="line">        <span class="keyword">if</span>(y is NOT in live_out[s])</span><br><span class="line">            <span class="built_in">remove</span>(s);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h5><ul><li>在后端(汇编代码级)进行</li><li>寄存器分配、指令调度、窥孔优化等</li></ul><h1 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a><strong>Reflection</strong></h1><p>OS：终于把本科分流后欠下的债还了一部分了。谁懂啊，从计算机专业分流去了大数据后，研究生阶段又跑来搞系统；</p><p>参考资源：</p><p>网课：<a href="https://www.bilibili.com/video/BV17W41187gL?spm_id_from=333.788.videopod.episodes&amp;vd_source=93e39300d281cef5ad42ab13d4028d04">编译原理 — 中科大_哔哩哔哩_bilibili</a></p><p>书籍：<a href="https://gitee.com/Microservice-Framework/E-book.git">编译原理(原书第2版)(龙书) .pdf · 曾彩军/E-book - Gitee.com</a></p>]]></content>
      
      
      <categories>
          
          <category> CS基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TrackFM:Far-out Compiler Support for a Far Memory World</title>
      <link href="/2025/02/19/TrackFM-Far-out-Compiler-Support-for-a-Far-Memory-World/"/>
      <url>/2025/02/19/TrackFM-Far-out-Compiler-Support-for-a-Far-Memory-World/</url>
      
        <content type="html"><![CDATA[<p>Large memoryworkloads with favorable locality ofreference<br>can benefit by extending the memory hierarchy across ma-<br>chines. Systems that enable such far memory configurations<br>can improve application performance and overall memory<br>utilization in a cluster. There are two current alternatives<br>for software-based far memory: kernel-based and library-<br>based. Kernel-based approaches sacrifice performance to<br>achieve programmer transparency, while library-based ap-<br>proaches sacrifice programmer transparency to achieve per-<br>formance. We argue for a novel third approach, the compiler-<br>based approach, which sacrifices neither performance nor<br>programmer transparency. Modern compiler analysis and<br>transformation techniques, combined with a suitable tightly-<br>coupled runtime system, enable this approach. We describe<br>the design, implementation, and evaluation of TrackFM, a<br>new compiler-based far memory system. Through extensive<br>benchmarking, we demonstrate that TrackFM outperforms<br>kernel-based approaches by up to 2× while retaining their<br>programmer transparency, and that TrackFM can perform<br>similarly to a state-of-the-art library-based system (within<br>10%). The application is merely recompiled to reap these<br>benefits.</p>]]></content>
      
      
      <categories>
          
          <category> PaperNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud computing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/18/hello-world/"/>
      <url>/2025/02/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
