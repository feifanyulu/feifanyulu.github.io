<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>QUIC:超越TCP的新一代网络协议</title>
      <link href="/2025/03/24/QUIC/"/>
      <url>/2025/03/24/QUIC/</url>
      
        <content type="html"><![CDATA[<p>QUIC是一种加密、多路复用和低延迟的传输协议，旨在提高HTTPS流量的传输性能，并实现传输机制的快速部署和持续发展。QUIC已在Google全球数千台服务器上部署，并用于向一系列客户端提供流量，包括广泛使用的Web浏览器(Chrome)和流行的移动的视频流应用程序(YouTube)。</p><p><a href="https://dl.acm.org/doi/10.1145/3098822.3098842">The QUIC Transport Protocol | Proceedings of the Conference of the ACM Special Interest Group on Data Communication</a></p><p><a href="https://www.chromium.org/quic/">QUIC，一种基于 UDP 的多路复用传输</a></p><h1 id="HTTP发展史"><a href="#HTTP发展史" class="headerlink" title="HTTP发展史"></a>HTTP发展史</h1><p> <a href="https://zhuanlan.zhihu.com/p/102561034">一文读懂 HTTP/1HTTP/2HTTP/3 - 知乎 2020-05-25</a></p><p>​    从 1989 年万维网（www）诞生，HTTP（HyperText Transfer Protocol）经历了众多版本迭代，<a href="https://zhida.zhihu.com/search?content_id=110922002&amp;content_type=Article&amp;match_order=1&amp;q=WebSocket&amp;zhida_source=entity">WebSocket</a> 也在期间萌芽。1991 年 HTTP0.9 被发明。1996 年出现了 HTTP1.0。2015 年 <a href="https://zhida.zhihu.com/search?content_id=110922002&amp;content_type=Article&amp;match_order=1&amp;q=HTTP2&amp;zhida_source=entity">HTTP2</a> 正式发布。2020 年 <a href="https://zhida.zhihu.com/search?content_id=110922002&amp;content_type=Article&amp;match_order=1&amp;q=HTTP3&amp;zhida_source=entity">HTTP3</a> 或能正式使用。</p><img src="/2025/03/24/QUIC/image-20250330192046564.png" class="" title="image-20250330192046564"><ul><li><p>HTTP1.1</p><blockquote><p>缺陷</p><p>队头阻塞：一个TCP连接通道同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态；</p><p>无状态特性：对于连接状态没有记忆能力，每一个连接都是一个新的连接；</p><p>不安全性：传输内容没有加密，中途可能被篡改和劫持；</p><p>不支持服务端主动推送。</p></blockquote></li><li><p>SPDY协议</p><p>随着网络技术的发展，1999 年设计的 HTTP/1.1 已经不能满足需求，所以 Google 在 2009 年设计了基于 TCP 的 SPDY ，后来 SPDY 的开发组推动 SPDY 成为正式标准，不过最终没能通过。不过 SPDY 的开发组全程参与了 HTTP/2 的制定过程，参考了 SPDY 的很多设计，所以我们一般认为 SPDY 就是 HTTP/2 的前身。</p><blockquote><p>特性</p><p>多路复用：允许一个连接上可以无限制的并发流；(解决对头阻塞)</p><p>头部压缩：使用专门的HPACK算法，每次请求和响应只发送差异头部，一般可以达到 50%~90% 的高压缩率。</p><p>请求优先级：在网络通道被非关键资源堵塞时，高优先级的请求会被优先处理。</p><p>服务端推送：可以让服务端主动把资源文件推送给客户端。</p><p>提高安全性：支持使用 HTTPS 进行加密传输。</p></blockquote></li><li><p>HTTP2</p><p>HTTP2 基于 SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接。</p><ul><li><p>新增特性</p><blockquote><p>二进制分帧：首先，HTTP2 没有改变 HTTP1 的语义，只是在应用层使用二进制分帧方式传输。因此，也引入了新的通信单位：<strong>帧、消息、流</strong>。为多路复用提供了底层支持。</p><p>多路复用：一个域名对应一个连接，一个流代表了一个完整的<strong>请求-响应</strong>过程。<strong>帧</strong>是最小的数据单位，每个<strong>帧</strong>会标识出该帧属于哪个<strong>流</strong>，<strong>流</strong>也就是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多个流。</p></blockquote></li><li><p>缺陷</p><blockquote><p>TCP 以及 TCP+TLS 建立连接的延时；</p><p>TCP 的队头阻塞并没有彻底解决：TCP 为了保证可靠传输，有一个“超时重传”机制，丢失的包必须等待重传确认。HTTP2 出现丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。</p></blockquote></li></ul></li></ul><h1 id="为什么需要QUIC？"><a href="#为什么需要QUIC？" class="headerlink" title="为什么需要QUIC？"></a>为什么需要QUIC？</h1><p><a href="https://zhuanlan.zhihu.com/p/32553477">科普：QUIC协议原理分析 - 知乎</a></p><p>一方面是历史悠久使用广泛的古老协议，另外一方面用户的使用场景对传输性能的要求又越来越高。如下几个由来已久的问题和矛盾就变得越来越突出。</p><ol><li><p>协议历史悠久导致中间设备僵化。</p><blockquote><p>TCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。</p></blockquote></li><li><p>依赖于操作系统的实现导致协议本身僵化。</p><blockquote><p>TCP 是由操作系统在内核协议栈层面实现的，操作系统升级很麻烦，所以 TCP 的迭代却非常缓慢。</p></blockquote></li><li><p>建立连接的握手延迟大。</p></li><li><p>HTTP/没有彻底解决队头阻塞。</p><blockquote><p>队头阻塞主要是 TCP 协议的可靠性机制引入的。TCP 使用序列号来标识数据的顺序，数据必须按照顺序处理，如果前面的数据丢失，后面的数据就算到达了也不会通知应用层来处理。</p><p>另外 TLS 协议层面也有一个队头阻塞，因为 TLS 协议都是按照 record 来处理数据的，如果一个 record 中丢失了数据，也会导致整个 record 无法正确处理。</p></blockquote></li></ol><p>​    总之，TCP 和 TLS1.2 之前的协议存在着结构性的问题，如果继续在现有的 TCP、TLS 协议之上实现一个全新的应用层协议，依赖于操作系统、中间设备还有用户的支持。部署成本非常高，阻力非常大。</p><p>​    无论 SPDY 还是 HTTP/2，都是基于 TCP 的，而UDP 相比效率上存在天然的劣势，因为 UDP 本身没有连接的概念，不需要三次握手，优化了连接建立的握手延迟，同时在应用程序层面实现了 TCP 的可靠性，TLS 的安全性和 HTTP2 的并发性，只需要用户端和服务端的应用程序支持 QUIC 协议，完全避开了操作系统和中间设备的限制。所以 2013 年 Google 开发了基于 UDP 的名为 <a href="https://zhida.zhihu.com/search?content_id=120012913&amp;content_type=Article&amp;match_order=1&amp;q=QUIC&amp;zhida_source=entity">QUIC</a> 的传输层协议，QUIC 全称 Quick UDP Internet Connections，希望它能替代 TCP，使得网页传输更加高效。后经<strong><a href="https://link.zhihu.com/?target=https%3A//mailarchive.ietf.org/arch/msg/quic/RLRs4nB1lwFCZ_7k0iuz0ZBa35s">提议</a></strong>，互联网工程任务组正式将基于 QUIC 协议的 HTTP （<a href="https://zhida.zhihu.com/search?content_id=120012913&amp;content_type=Article&amp;match_order=1&amp;q=HTTP+over+QUIC&amp;zhida_source=entity">HTTP over QUIC</a>）重命名为 HTTP/3。它真正“完美”地解决了“队头阻塞”问题。    </p><p>QUIC，你就记住两个核心：采用UDP传输层、使用TLS 1.3协议</p><h1 id="QUIC生态圈发展简史"><a href="#QUIC生态圈发展简史" class="headerlink" title="QUIC生态圈发展简史"></a>QUIC生态圈发展简史</h1><p>下图是 QUIC 从创建到现在为止的一些比较重要的时间节点，2021 年，QUIC V1 即将成为 RFC，结束百花齐放的态势。</p><img src="/2025/03/24/QUIC/z12q8ut8so-20250330210651057.png" class="" title="img"><h1 id="QUIC协议详解"><a href="#QUIC协议详解" class="headerlink" title="QUIC协议详解"></a>QUIC协议详解</h1><p><a href="https://zhuanlan.zhihu.com/p/32553477">科普：QUIC协议原理分析 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/405387352">QUIC 协议详解 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/143464334">HTTP/3 原理实战 - 知乎</a></p><img src="/2025/03/24/QUIC/v2-d61a62fdfb08ed3882e1018136ce6b2f_1440w.jpg" class="" title="img"><p>从协议栈可以看出：QUIC = HTTP/2 + TLS1.3+ UDP</p><h2 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h2><p>一个 QUIC 数据包的格式如下：</p><img src="/2025/03/24/QUIC/image-20250331152540208.png" class="" title="image-20250331152540208"><ul><li>由header和data两部分组成：</li></ul><img src="/2025/03/24/QUIC/v2-60231adb6c7014c7f043712839f77ab5_1440w.jpg" class="" title="img"><ul><li><p>Frame Type: 数据帧的类型，标识了它的用途，占用1个字节</p><img src="/2025/03/24/QUIC/v2-eb52f6d7f4d12a2599085f62f9240162_1440w.jpg" class="" title="img"><blockquote><p>Bit 7：必须设置为 1，表示 Stream 帧;</p><p>Bit 6：如果设置为 1，表示发送端在这个 stream 上已经结束发送数据，流将处于半关闭状态;</p><p>Bit 5：如果设置为 1，表示 Stream 头中包含 Data length 字段;</p><p>Bit 4,3,2：表示 offset 的长度。000 表示 0 字节，001 表示 2 字节，010 表示 3 字节，以此类推;</p><p>Bit 1,0：表示 Stream ID 的长度。00 表示 1 字节，01 表示 2 字节，10 表示 3 字节，11 表示 4 字节。</p><p>一些常见的数据帧类型：</p><ol><li><strong>PING帧：</strong> 用于测试连接的可用性。PING帧不包含负载，只是用于确认连接是否存活。</li><li><strong>ACK帧：</strong> 用于确认收到的数据包。它包含有关已收到的数据包的信息，以确保数据的可靠传输。</li><li><strong>RESET_STREAM帧：</strong> 用于重置特定数据流的状态。当一个数据流需要被中断或重新开始时，可以使用RESET_STREAM帧。</li><li><strong>STOP_SENDING帧：</strong> 用于停止向特定的数据流发送数据。这可以用于暂停数据传输或处理异常情况。</li><li><strong>CRYPTO帧：</strong> 用于传输加密数据。在QUIC中，加密通常是在连接建立过程中进行的，CRYPTO帧用于在已建立的连接上传输加密的应用层数据。</li><li><strong>STREAM帧：</strong> 用于传输普通数据流。STREAM帧可以包含应用层数据，用于在连接上进行双向通信，支持多路复用。</li></ol></blockquote></li><li><p>Payload：应用数据</p><blockquote><p>Stream ID： 流 ID，用于标识数据包所属的流。后面的流量控制和多路复用会涉及到</p><p>Offset：偏移量，表示该数据包在整个数据中的偏移量，用于数据排序。</p><p>Data Length：数据长度，占用 2 个字节，表示实际应用数据的长度</p><p>Data：实际的应用数据</p></blockquote></li></ul><h2 id="0RTT建立连接"><a href="#0RTT建立连接" class="headerlink" title="0RTT建立连接"></a>0RTT建立连接</h2><ul><li><p>0RTT建立连接</p><img src="/2025/03/24/QUIC/v2-b1dfebc37d7049b2446156460dcec5c6_1440w.jpg" class="" title="img"><ul><li><p>HTTP/2的连接需要三次握手3RTT，如果考虑会话复用，即把第一次握手算出来的对称密钥缓存起来，那么也需要 2 RTT；</p></li><li><p>QUIC基于TLS1.3实现，只需在首次建立连接时需要1RTT，后续再次连接只需0RTT；</p><blockquote><p>原理：在首次连接时，客户端缓存了ServerConfig，下次建连直接使用缓存数据计算通信密钥。</p></blockquote></li></ul></li><li><p>前向安全性</p><p>假设攻击者记录下所有的通信数据和公开参数，一旦服务器的私钥泄漏了，那之前通信的所有数据就都可以破解了。为了解决这个问题，需要为每次会话都创建一个新的通信密钥，来保证<a href="https://zhida.zhihu.com/search?content_id=178216113&amp;content_type=Article&amp;match_order=1&amp;q=前向安全&amp;zhida_source=entity">前向安全</a>性。</p><img src="/2025/03/24/QUIC/image-20250331165945325.png" class=""><p>客户端缓存的 ServerConfig 是服务器静态配置的，是可以长期使用的。客户端通过 ServerConfig 实现 0-RTT 握手，使用会话密钥 sessionKey 保证通信数据的前向安全。QUIC不会使用复用会话密钥，每次连接都生成一个新的密钥；</p><blockquote><p>（1）客户端：</p><ul><li><p><strong>生成随机数 a</strong>，选择公开的大数 G 和 P，计算 A=a*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息。</p></li><li><p>直接使用缓存的 ServerConfig <strong>计算初始密钥 initKey</strong> (K1)= aB = ab*G%P，加密发送应用数据 1；</p></li></ul><p>（2）服务器：</p><ul><li><p>根据 Client Hello 消息<strong>解码初始密钥 initKey</strong> = bA = ba*G%P</p></li><li><p><strong>生成随机数 c</strong>，计算 C=c<em>G%P，<em>*使用 initKey 加密 C</em></em>，发送给客户端，也就是 Server Hello 消息</p></li></ul><p>（3）客户端：<strong>使用 initKey 解码获取 C</strong>，<strong>计算会话密钥 sessionKey</strong> (k2)= a<em>C = a</em>c*G%P，加密发送应用数据 2;</p><p>（4）服务器：计算会话密钥 sessionKey = c<em>A = c</em>a*G%P，解密获取应用数据 2</p></blockquote></li></ul><h2 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h2><p>什么叫连接迁移呢？</p><p>​    就是当其中任何一个元素发生变化时，这条连接依然维持着，能够保持业务逻辑不中断。当然这里面主要关注的是客户端的变化，因为客户端不可控并且网络环境经常发生变化，而服务端的 IP 和端口一般都是固定的。比如大家使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，需要重新建立和服务端的 TCP 连接。又比如大家使用公共 NAT 出口时，有些连接竞争时需要重新绑定端口，导致客户端的端口发生变化，同样需要重新建立 TCP 连接。</p><ul><li>TCP的连接基于四元组：<code>源IP、源端口、目的IP、目的端口</code>；只要其中一个发生变化，就需要重新连接。</li><li>QUIC的连接基于64位的随机数Connection ID，网络切换并不会影响Connetion ID的变化。</li></ul><img src="/2025/03/24/QUIC/image-20250331182407956.png" class="" title="image-20250331182407956"><h2 id="队头阻塞-多路复用"><a href="#队头阻塞-多路复用" class="headerlink" title="队头阻塞/多路复用"></a>队头阻塞/多路复用</h2><ul><li><p>HTTP/1.1：只有上一个请求的所有数据包被传输完毕下一个请求的数据包才可以传输;</p></li><li><p>HTTP/2：可以同时并行处理多个请求，每个请求被拆分为多个数据包通过一条TCP连接同时被传输。</p><p>​    一个请求就对应一条流，通过 Stream ID 就可以判断该数据帧属于哪个请求，假设有 A 和 B 两个请求，对应的 Stream ID 分别为 1 和 2，那这个 TCP 连接上传输的数据大概如下：</p><p><style>.qbsgpgfpsolh{zoom:67%;}</style><img src="/2025/03/24/QUIC/v2-33cc6b4531a4de38b94da1b2a7b6ee8a_1440w.jpg" class="qbsgpgfpsolh" alt="img"></p><p>虽然在 HTTP 应用层，可以同时发送多个请求，但是在 TCP 传输层，仍然只有 1 个滑动窗口来发送这些数据包，考虑下面的情形：</p><p><style>.nkguovzbwolx{zoom:67%;}</style><img src="/2025/03/24/QUIC/v2-0454bee543863c36908765244b989a56_1440w.jpg" class="nkguovzbwolx" alt="img"></p><p>客户端发送的 5 个数据包（56789）服务器都收到了，并且回应了 5 个 ACK，但是第 5 个数据包的 ACK 丢失了，导致客户端的发送窗口无法向前移动，也就无法发送新的数据。但是如果发生丢包，应用层需要等待丢包的重传，才能继续读取后面的数据包，即使其他流的数据包已经到达仍不能处理，这整条连接会发生阻塞。这就是 TCP 层的队头阻塞问题。</p><img src="/2025/03/24/QUIC/v2-2dd2a9fb8693489b9a0b24771c8a40a1_1440w.jpg" class="" title="img"><p>不仅如此，由于 HTTP/2 强制使用 HTTPS，而 HTTPS 使用的 TLS 协议也存在队头阻塞问题。TLS 基于 Record 组织数据，将一堆数据放在一起（即一个 Record）加密，加密完后又拆分成多个 TCP 包传输。Record 是 TLS 协议处理的最小单位，一般每个 Record 16K，包含 12 个 TCP 包。由于一个 record 必须经过数据一致性校验才能进行加解密，如果 12 个 TCP 包中有任何一个包丢失，那么整个 Record 都无法解密。<img src="/2025/03/24/QUIC/image-20250331191231592.png" class="" title="image-20250331191231592"></p><p>HTTP/2 虽然通过多路复用解决了 HTTP 层的队头阻塞，但仍然存在 TCP 层的队头阻塞。</p></li><li><p>那 QUIC 是如何解决 TCP 层的队头阻塞问题的呢？其实很简单，HTTP/2 之所以存在 TCP 层的队头阻塞，是因为所有请求流都共享一个滑动窗口，那如果给每个请求流都分配一个独立的滑动窗口，是不是就可以解决这个问题了？QUIC 就是这么做的： </p><ul><li><p><strong>独立的逻辑流：</strong> QUIC允许在单个连接上并行传输多个逻辑数据流。每个数据流都是独立管理的，这意味着一个数据流的延迟或中断不会影响其他数据流的传输。这有助于提高网络效率，特别是在处理多个请求和响应时。</p></li><li><p><strong>避免HOL（Head-of-Line）阻塞：</strong> QUIC通过允许多个数据流在单个连接上独立传输，解决了HOL阻塞问题。这意味着即使一个数据流遇到问题，其他数据流仍然可以继续传输，而不会受到影响。这有助于提高整体效率和性能。</p></li><li><p><strong>避免 TLS 协议存在的队头阻塞：</strong>QUIC 最基本的传输单元是 Packet，不会超过最大传输单元MTU 的大小，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞；</p><img src="/2025/03/24/QUIC/a9f643ec240469dd7dbd3c9d4fef6d70.png" class="" title="img"><img src="/2025/03/24/QUIC/v2-9e649330ab729b6438a8586c8b4f1bd3_1440w.jpg" class="" title="img"></li><li><p>当然，并不是所有的 QUIC 数据都不会受到队头阻塞的影响，比如 QUIC 当前也是使用 <a href="https://zhida.zhihu.com/search?content_id=5210566&amp;content_type=Article&amp;match_order=1&amp;q=Hpack+压缩算法&amp;zhida_source=entity">Hpack 压缩算法</a> ，由于算法的限制，丢失一个头部数据时，可能遇到队头阻塞。</p><blockquote><p><strong>HPACK 和 QPACK 的工作原理</strong></p><p>HTTP/2（HPACK）和 HTTP/3（QPACK）都使用头部压缩技术来减少请求/响应的开销，但它们的实现方式不同，主要区别在于 <strong>如何避免队头阻塞（HOL Blocking）</strong>。</p><p>1、HPACK</p><p>HPACK 是 HTTP/2 的头部压缩算法，它通过 <strong>静态表 + 动态表 + Huffman 编码</strong> 来减少头部大小。</p><ul><li><p>静态表</p><p>HPACK 预定义了 61 个常见 HTTP 头部字段（如 <code>:method: GET</code>、<code>:path: /</code>），客户端和服务器可以直接引用它们的索引号，而无需传输完整字符串。</p><p>| 索引 | 头部字段       | 值          |<br>| —— | ——————— | —————- |<br>| 2    | <code>:method</code>      | <code>GET</code>       |<br>| 4    | <code>:path</code>        | <code>/</code>         |<br>| 24   | <code>content-type</code> | <code>text/html</code> |</p><p>如果客户端发送 <code>GET /index.html</code>，可以编码为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:method: GET   → 索引 2  </span><br><span class="line">:path: /index.html → 先发送索引 4（/），再发送 <span class="string">&quot;index.html&quot;</span>（Huffman 编码）</span><br></pre></td></tr></table></figure></li><li><p>动态表</p><p>HPACK 允许客户端和服务器在通信过程中动态添加头部字段到动态表，后续请求可以引用这些索引，减少重复传输。</p><p><strong>示例：</strong></p><ol><li><p>第一次请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user-agent: Mozilla/5.0</span><br></pre></td></tr></table></figure><p>→ 动态表新增条目（假设索引 62）。</p></li><li><p>第二次请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user-agent: Mozilla/5.0</span><br></pre></td></tr></table></figure><p>→ 直接发送索引 62，无需再传完整字符串。</p></li></ol></li><li><p>Huffman编码</p><p>对于不在表中的头部字段，HPACK 使用 Huffman 编码进一步压缩字符串。</p></li></ul><p>由于 HPACK 的 <strong>动态表是按顺序更新</strong> 的，如果某个头部帧丢失，后续帧可能无法正确解码（因为它们可能依赖丢失的动态表更新）。</p><p>2、QPACK</p><p>QPACK 是 HTTP/3 的头部压缩算法，针对 QUIC 的无序传输特性优化，动态表更新（Encoder Stream）和头部帧分离，避免阻塞。</p><ul><li><p>仍然使用静态表 + 动态表</p><p>QPACK 保留了 HPACK 的静态表和动态表机制，但 <strong>动态表的更新方式不同</strong>。</p></li><li><p>引入“单向流”管理动态表</p><p>HPACK 的动态表更新和头部帧在同一个流上传输，而 QPACK 使用 <strong>两个独立的单向流</strong>：</p><p><strong>Encoder Stream（编码流）</strong>：客户端 → 服务器，用于更新动态表（新增/删除条目）。</p><p><strong>Decoder Stream（解码流）</strong>：服务器 → 客户端，用于确认动态表更新是否成功。</p></li><li><p>允许乱序引用</p><p>QPACK 允许头部帧 <strong>引用尚未确认的动态表条目</strong>，但需要额外的机制（如“相对索引”）来保证正确解码。</p></li></ul></blockquote></li></ul></li></ul><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>​    TCP 拥塞控制由 4 个核心算法组成：慢启动、拥塞避免、快速重传和快速恢复；</p><p>​    QUIC 协议当前默认使用了 TCP 协议的 <a href="https://zhida.zhihu.com/search?content_id=5210566&amp;content_type=Article&amp;match_order=1&amp;q=Cubic+拥塞控制算法&amp;zhida_source=entity">Cubic 拥塞控制算法</a> ，并在此基础上做了不少改进。同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法。下面介绍一些 QUIC 改进的拥塞控制的特性。</p><h3 id="热插拔"><a href="#热插拔" class="headerlink" title="热插拔"></a>热插拔</h3><p>什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。</p><ol><li><p>QUIC 修改拥塞控制策略只需要在应用层操作，不需要操作系统，不需要内核支持。</p><blockquote><p>这是一个飞跃，因为传统的 TCP 拥塞控制的修改，需要在系统层面进行操作，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。</p></blockquote></li><li><p>QUIC 会根据不同的网络环境、用户来动态选择拥塞控制算法。即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。</p><blockquote><p>就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。关于应用层的可插拔拥塞控制模拟，可以对 socket 上的流为对象进行实验。</p></blockquote></li><li><p>应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。</p></li></ol><h3 id="可靠性传输"><a href="#可靠性传输" class="headerlink" title="可靠性传输"></a>可靠性传输</h3><p>​    QUIC 同样是一个可靠的协议，它使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。这样发送方接收到确认消息时就能方便地知道 ACK 对应的是原始包还是重传包的响应了。</p><p>解决了TCP重传模糊问题：TCP连接对于原始包和重传包接收到的 ACK 序号一样，客户端无法分清ACK是原始包还是重传包的响应，此时会影响RTT的采样，如果客户端认为是重传包的 ACK，但实际上是原始包的ACK，会导致采样 RTT 偏小，使得超时重传时间偏小。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 会对每个 TCP 连接进行流量控制，流量控制的意思是让发送方不要发送太快，要让接收方来得及接收，不然会导致数据溢出而丢失，TCP 的流量控制主要通过滑动窗口来实现的。可以看出，拥塞控制主要是控制发送方的发送策略，<strong>但没有考虑到接收方的接收能力</strong>，流量控制是对这部分能力的补齐。QUIC考虑到接收方的接受能力；</p><ul><li><p><strong>基于 stream 和 connection 级别的流量控制。</strong></p><p>为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。 Stream 可以认为就是一条 HTTP 请求。 Connection 可以类比一条 TCP 连接。多路复用意味着在一条 Connetion 上会同时存在多条 Stream。</p><ul><li><p>基于 stream</p><p>QUIC 接收者会通告每个流中最多想要接收到的数据的绝对字节偏移。随着数据在特定流中的发送，接收和传送，接收者发送 WINDOW_UPDATE 帧，该帧增加该流的通告偏移量限制，允许对端在该流上发送更多的数据。</p></li><li><p>基于连接级别的流控制</p><p>QUIC 还实现连接级的流控制，以限制 QUIC 接收者愿意为连接分配的总缓冲区。连接的流控制工作方式与流的流控制一样，但传送的字节和最大的接收偏移是所有流的总和。</p><img src="/2025/03/24/QUIC/v2-5f2ad22131453b3fd4c6351094b6b581_1440w.jpg" class="" title="img"></li></ul></li><li><p>QUIC 实现流量控制的原理比较简单：</p><p>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</p><p>QUIC 的流量控制和 TCP 有点区别，TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号。</p></li><li><p>拥塞控制是通过拥塞窗口限制发送方的数据量，避免整个网络发生拥塞。那拥塞窗口（cwnd）和滑动窗口（发送窗口：swnd，接收窗口：rwnd）有什么关系呢？</p><p>swnd = min（cwnd，rwnd）</p><p>也就是说，发送窗口的大小是由接收窗口和拥塞窗口共同决定的。那拥塞窗口的大小是如何计算的？通过 4 个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p><ul><li><p>慢启动：初始拥塞窗口大小cwnd=1，当发送方每收到一个 ACK，拥塞窗口就加 1（cwnd++）；</p><img src="/2025/03/24/QUIC/v2-54d7f3cc6ec67a9ae47fa5dfa3fccfc0_1440w.jpg" class="" title="img"></li><li><p>拥塞避免：当拥塞窗口大小超过慢启动上限后，就会进入拥塞避免阶段。由此可知，在拥塞避免阶段，拥塞窗口是线性增长的。</p><blockquote><p><strong>拥塞避免算法：</strong> 当发送方每收到一个 ACK，拥塞窗口就加 1/cwnd；</p></blockquote><img src="/2025/03/24/QUIC/v2-1072c63fd6e97e671affe2d9346c3836_1440w.jpg" class="" title="img"></li><li><p>拥塞发生：重传有两种(超时重传和快速重传)</p><p>1、超时重传，使用的拥塞发生算法为：</p><blockquote><ul><li>ssthresh = cwnd / 2</li><li>cwnd = 1</li></ul></blockquote><p>重新使用慢启动和拥塞避免算法增加拥塞窗口的大小。</p><img src="/2025/03/24/QUIC/v2-dcefc32fcbaca9acf5a347580b56ff3c_1440w.jpg" class="" title="img"><p>2、快速重传（发送方收到 3 个相同的 ACK），使用的拥塞发生算法为：</p><blockquote><ul><li>cwnd = cwnd / 2</li><li>ssthresh = cwnd</li></ul></blockquote><p>接下来就会进入快速恢复阶段。</p></li><li><p>快速恢复</p><blockquote><p>快速恢复算法：cwnd = ssthresh + 3（因为收到 3 个 ACK），然后进入拥塞避免阶段。</p></blockquote><img src="/2025/03/24/QUIC/v2-9158217fe2e02f6b17a29aadf649cdd2_1440w.jpg" class="" title="img"></li></ul></li><li><p>常见算法</p><blockquote><p>New Reno：基于丢包检测</p><p>CUBIC：基于丢包检测</p><p>BBR：基于网络带宽</p></blockquote><p>和 TCP 不同的是，QUIC 是在用户空间实现的拥塞控制，可以非常灵活的设置，甚至可以为每一个请求都设置一种拥塞控制算法。</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>加密认证的报文</strong></p><p>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p><p>但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。</p><p><strong>全应用态协议栈</strong></p><p>QUIC 核心逻辑都在用户态，能灵活的修改连接参数、替换拥塞算法、更改传输行为。而 TCP 核心实现在内核态，改造需要修改内核并且进行系统重启，成本极高。</p><p><style>.jywkjkhtsfws{zoom:80%;}</style><img src="/2025/03/24/QUIC/e167057a6f62b072916d4e59ac2b3694.jpeg" class="jywkjkhtsfws" alt="img"></p><h2 id="QUIC协议的缺点"><a href="#QUIC协议的缺点" class="headerlink" title="QUIC协议的缺点"></a>QUIC协议的缺点</h2><p><strong>增加了遭受攻击的脆弱性</strong></p><p>​    QUIC协议更容易受到分布式拒绝服务（DDoS）攻击的威胁。因为它是无连接的，不需要像TCP那样进行三次握手，攻击者更容易发起反射和放大攻击，通过伪造源IP地址来淹没目标服务器，使其不可用。QUIC的无连接性使其更难以进行流量控制和访问控制，从而增加了DDoS攻击的可能性。</p><p><strong>兼容性问题</strong></p><p>​    QUIC协议相对较新，可能与某些旧设备、网络设备或防火墙不兼容。一些应用程序需要精确控制网络行为，而QUIC的新特性可能不适用于所有用例。因此，在部署QUIC时，需要考虑与现有基础设施和设备的兼容性问题。</p><p><strong>传输速率较低</strong></p><p>​    尽管QUIC被设计为提供更快速和高效的数据传输，但它的传输速率可能受到加密和身份验证机制的影响。QUIC在数据包传输方面增加了额外的开销，这可能导致较小数据包的传输速率较低，尤其是在高延迟网络中。</p><p><strong>故障排除困难</strong></p><p>​    与TCP相比，使用QUIC进行网络故障排除可能更加复杂。由于QUIC的加密和身份验证功能，诊断与数据包丢失、网络拥塞或性能问题相关的问题可能需要更高级的网络监控工具和专业知识。解决问题的难度可能增加，因为数据包内容和流量可能不可见。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>实时 Web 和移动应用程序</strong></p><p>实时通信应用程序，如视频通话、语音聊天和即时消息，需要低延迟和可靠的数据传输。QUIC通过独立的流和拥塞控制机制，提供了快速且高效的数据传输，适用于这些应用。</p><p><strong>物联网设备通信</strong></p><p>物联网设备通常在受限的网络环境中运行，使用TCP或MQTT等传输协议可能导致高延迟和数据包丢失。QUIC在高延迟和丢包的网络条件下表现出色，因此适用于与物联网设备的通信，提供可靠和高效的替代方案。</p><p><strong>车联网和联网汽车</strong></p><p>车联网生态系统需要实时的数据交换，以提供车辆跟踪、交通管理和安全功能。QUIC的低延迟、多路复用和数据包恢复能力有助于确保车辆和基础设施之间的可靠通信，并提高车联网系统的性能。</p><p><strong>云计算</strong></p><p>云计算涉及通过互联网交付计算资源。QUIC可以提供低延迟和端到端加密，从而改善云应用程序的用户体验和安全性。</p><p><strong>支付和电子商务应用程序</strong></p><p>支付和电子商务应用程序需要安全可靠的数据传输，以保护用户的敏感信息。QUIC通过使用TLS加密和可靠的HTTP3流，为这些应用程序提供了更高的安全性和性能，同时提高了用户体验。</p><h1 id="基于QUIC的相关工作"><a href="#基于QUIC的相关工作" class="headerlink" title="基于QUIC的相关工作"></a>基于QUIC的相关工作</h1><p>具体实现上，各家会有比较大的差异。虽然从协议层面上来看，IETF QUIC 传输层的通用性设计，使得它可以适配各类业务场景，但在实践中，每个企业都有自己的侧重点。比如，谷歌会更多从浏览器角度出发，微软则更侧重于 Windows 等的适配，而像阿里手机淘宝这样的 App 厂商则需要更多考虑移动端适配和性能问题。</p><h2 id="腾讯TQUIC网络传输协议"><a href="#腾讯TQUIC网络传输协议" class="headerlink" title="腾讯TQUIC网络传输协议"></a>腾讯TQUIC网络传输协议</h2><p><a href="https://cloud.tencent.com/developer/article/1908451?policyId=1003">提速 30%！腾讯TQUIC 网络传输协议-腾讯云开发者社区-腾讯云 2021-12-01</a></p><p>腾讯核心业务用户登录耗时降低 30%，下载场景 500ms 内请求成功率从 HTTPS 的 60%提升到 90%，腾讯的移动端 APP 在弱网、跨网场景下取得媲美正常网络的用户体验。这是腾讯网关 sTGW 团队打造的 TQUIC 网络协议栈在实时通信、音视频、在线游戏、在线广告等多个腾讯业务落地取得的成果。TQUIC 基于下一代互联网传输协议 HTTP3/QUIC 深度优化，日均请求量级突破千亿次，在腾讯云 CLB、CDN 开放云客户使用。</p><blockquote><p>STGW团队：是腾讯内部负责开发和维护STGW(Seven-layer Traffic Gateway，七层流量网关)的核心团队</p></blockquote><img src="/2025/03/24/QUIC/image-20250401143536193.png" class="" title="image-20250401143536193"><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h2 id="蚂蚁集团QUIC落地"><a href="#蚂蚁集团QUIC落地" class="headerlink" title="蚂蚁集团QUIC落地"></a>蚂蚁集团QUIC落地</h2><p><a href="https://cloud.tencent.com/developer/article/1822608?policyId=1004">QUIC 协议在蚂蚁落地综述-腾讯云开发者社区-腾讯云2021-05-11</a> </p><p>蚂蚁集团支付宝客户端团队与接入网关团队于 2018 年下半年开始在移动支付、海外加速等场景落地 QUIC。</p><h3 id="一套落地框架"><a href="#一套落地框架" class="headerlink" title="一套落地框架"></a>一套落地框架</h3><p>​    蚂蚁的接入网关是基于多进程的 NGINX 开发的 (内部称为 Spanner，协议卸载的扳手)，而 UDP 在多进程编程模型上存在诸多挑战，典型的像无损升级等。为了设计一套完备的框架，我们在落地前充分考虑了服务端在云上部署上的方便性、扩展性、以及性能问题，设计了如下的落地框架以支撑不同的落地场景：</p><img src="/2025/03/24/QUIC/pcwxr606v9.png" class="" title="img"><p>在这套框架中，包括如下两个组件：</p><ol><li><p>QUIC LB 组件：基于 NGINX 4层 UDP Stream 模块开发，用来基于 QUIC DCID 中携带的服务端信息进行路由，以支持连接迁移。</p></li><li><p>NGINX QUIC 服务器：开发了 NGINX_QUIC_MODULE，每个 Worker 监听两种类型的端口： </p><p>（1）BASE PORT ，每个 Worker 使用的相同的端口号，以 Reuseport 的形式监听，并暴露给 QUIC LB，用以接收客户端过来的第一个 RTT 中的数据包，这类包的特点是 DCID 由客户端生成，没有路由信息。 </p><p>（2）Working PORT，每个 Worker 使用的不同的端口号，是真正的工作端口，用以接收第一个 RTT 之后的 QUIC 包，这类包的特定是 DCID 由服务端的进程生成携带有服务端的信息。</p></li></ol><p>当前框架支持的能力包括如下：</p><ol><li>在不用修改内核的情况下，完全在用户态支持 QUIC 的连接迁移，以及连接迁移时 CID 的 Update;</li><li>在不用修改内核的情况下，完全在用户态支持 QUIC 的无损升级以及其他运维问题;</li><li>支持真正意义上的 0RTT ，并可提升 0RTT 的比例;</li></ol><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><h4 id="技术点1：优雅的支持连接迁移能力"><a href="#技术点1：优雅的支持连接迁移能力" class="headerlink" title="技术点1：优雅的支持连接迁移能力"></a>技术点1：优雅的支持连接迁移能力</h4><p>在端到端的落地过程中，因为引入了负载均衡设备，会导致在连接迁移时，所有依赖五元组 Hash 做转发或者关联 Session 的机制失效。以 LVS 为例，连接迁移后， LVS 依靠五元组寻址会导致寻址的服务器存在不一致。即便 LVS 寻址正确，当报文到达服务器时，内核根据五元组关联进程，依然会寻址出错。同时，IETF Draft 要求，连接迁移时 CID 需要更新掉，这就为仅依靠 CID 来转发的计划同样变的不可行。</p><p>为了解决此问题，其设计了开篇介绍的落地框架，这里将方案做一些简化和抽象，整体思路如下图所示：</p><ol><li>在四层负载均衡上，设计了 QUIC LoadBalancer 的机制：<ol><li>在 QUIC 的 CID 中扩展了一些字段（ServerInfo）用来关联 QUIC Server 的 IP 和 Working Port 信息。</li><li>在发生连接迁移的时候，QUIC LoadBalancer 可以依赖 CID 中的 ServerInfo 进行路由，避免依赖五元组关联 Session 导致的问题。</li><li>在 CID 需要 Update 的时候，NewCID 中的 ServerInfo 保留不变，这样就避免在 CID 发生 Update 时，仅依赖 CID Hash 挑选后端导致的寻址不一致问题。</li></ol></li><li>在 QUIC 服务器多进程工作模式上，突破了 NGINX 固有的多 Worker 监听在相同端口上的桎梏，设计了多端口监听的机制，每个 Worker 在工作端口上进行隔离，并将端口的信息携带在对 First Initial Packet 的回包的 CID 中，这样代理的好处是：<ol><li>无论是否连接迁移，QUIC LB 都可以根据 ServerInfo，将报文转发到正确的进程。</li><li>而业界普遍的方案是修改内核，将 Reuse port 机制改为 Reuse CID 机制，即内核根据 CID 挑选进程。即便后面可以通过 ebpf 等手段支持，但其认为这种修改内核的机制对底层过于依赖，不利于方案的大规模部署和运维，尤其在公有云上。</li><li>使用独立端口，也有利于多进程模式下，UDP 无损升级问题的解决，这个我们在技术点 3 中介绍。</li></ol></li></ol><img src="/2025/03/24/QUIC/9y9go95j23.png" class="" title="img"><h4 id="技术点2：-提升0RTT握手比例"><a href="#技术点2：-提升0RTT握手比例" class="headerlink" title="技术点2： 提升0RTT握手比例"></a>技术点2： 提升0RTT握手比例</h4><p>QUIC 同样需要对握手的源地址做校验，否则便会存在 UDP 本身的 DDOS 问题，那 QUIC 是如何实现的？依赖 STK(Source Address Token) 机制。这里我们先声明下，跟 TLS 类似，QUIC 的 0RTT 握手，是建立在已经同一个服务器建立过连接的基础上，所以如果是纯的第一次连接，仍然需要一个 RTT 来获取这个 STK。</p><p>理论上说，只要客户端缓存了这个 STK，下次握手的时候带过来，服务端便可以直接校验通过，即实现传输层的 0RTT。但是真实的场景却存在<strong>如下两个问题</strong>：</p><ol><li>因为 STK 是服务端加密的，所以如果下次这个客户端路由到别的服务器上了，则这个服务器也需要可以识别出来。</li><li>STK 中 encode 的是上一次客户端的地址，如果下一次客户端携带的地址发生了变化，则同样会导致校验失败。此现象在移动端发生的概率非常大，尤其是 IPV6 场景下，客户端的出口地址会经常发生变化。</li></ol><p>第一个问题比较好解，我们只要保证集群内的机器生成 STK 的秘钥一致即可。<strong>第二个问题，我们的解题思路是</strong>：</p><ol><li><p>我们在 STK 中扩展了一个 Client ID, 这个 Clinet ID 是客户端通过无线保镖黑盒生成并全局唯一不变的，类似于一个设备的 SIMID，客户端通过加密的 Trasnport Parameter 传递给服务端，服务端在 STK 中包含这个 ID。</p></li><li><p>如果因为 Client IP 发生变化导致校验 STK 校验失败，便会去校验 Client ID，因为 ID 对于一个 Client 是永远不变的，所以可以校验成功，当然前提是，这个客户端是真实的。为了防止 Client ID 的泄露等，我们会选择性对 Client ID 校验能力做限流保护。</p><img src="/2025/03/24/QUIC/py3z9pmflw.png" class="" title="img"></li></ol><h4 id="技术点3：支持QUIC无损升级"><a href="#技术点3：支持QUIC无损升级" class="headerlink" title="技术点3：支持QUIC无损升级"></a>技术点3：支持QUIC无损升级</h4><p>设计了如下的 <strong>基于多端口轮转的无损升级方案</strong>，简单来说，我们让新老进程监听在不同的端口组并携带在 CID 中，这样 QUIC LB 就可以根据端口转发到新老进程。为了便于运维，我们采用端口轮转的方式，新老进程会在 reload N 次之后，重新开始之前选中的端口。</p><img src="/2025/03/24/QUIC/ijsdxqijvo.png" class="" title="img"><h4 id="技术点4：客户端智能选路"><a href="#技术点4：客户端智能选路" class="headerlink" title="技术点4：客户端智能选路"></a>技术点4：客户端智能选路</h4><p>在客户端上，设计了开篇介绍的 TCP 和 QUIC 相互 Backup 的链路，如下图所示，我们实时探测 TCP 链路和 QUIC 链路的 RTT、丢包率、请求完成时间、错误率等指标情况，并根据一定的量化方法对两种链路进行打分，根据评分高低，决定选择走哪种链路，从而避免寻址只走一条链路导致的问题。</p><img src="/2025/03/24/QUIC/0za9e1oiti.png" class="" title="img"><h2 id="阿里自研XQUIC"><a href="#阿里自研XQUIC" class="headerlink" title="阿里自研XQUIC"></a>阿里自研XQUIC</h2><p>2020-08-13 <a href="https://www.infoq.cn/article/SY0KFJ2pyJomB6sAkqls">阿里淘系自研标准化协议库XQUIC首次公开：直播高峰期卡顿可降低30%_架构_阿里巴巴淘系架构团队_InfoQ精选文章 2020-08-13</a></p><p>2022-01-07 <a href="https://www.infoq.cn/article/Ys2t7jLFRNFG9XDkeS27">阿里正式开源自研 XQUIC：已服务手淘上亿用户，网络耗时降低超 20%_开源_褚杏娟_InfoQ精选文章 2022-01-07</a></p><img src="/2025/03/24/QUIC/image-20250401135223479.png" class="" title="image-20250401135223479"><p>阿里大淘宝技术团队在2018年年底开始研发XQUIC的实现，2020年首次对外公开分享该技术，2021年8月正式对外发布，2022年正式开源。XQUIC 是阿里巴巴淘系架构团队自研的 IETF QUIC 标准化协议库实现，在手机淘宝上进行了广泛的应用，并在多个不同类型的业务场景下取得明显的效果提升。</p><p>XQUIC 协议的整体架构遵循 IETF QUIC 协议分层的设计理念，阿里团队针对传输层和应用层做了解耦实现。当前的 XQUIC 开源版本与之前发布的版本相比，新增了对 IETF RFC 版本的 QUIC v1 支持，对 QPACK 等部分功能模块进行了重构，增加了多路径支持等功能。到目前为止，XQUIC 已经在手淘正式版本为上亿用户提供了网络请求加速的体验优化。</p><p>XQUIC 本身服务手淘场景，目前更多地聚焦在短视频传输、视频/图片上传等典型的可靠传输场景，但 XQUIC 也将非可靠传输 / 半可靠传输场景纳入研发计划，未来也将结合社区开发者诉求，逐步纳入更多传输需求场景。</p><p>国内首个自研开源IETF QUIC协议栈XQUIC： 是一个适配移动端、轻量且高性能的传输协议库</p><p>XQUIC项目链接：<a href="https://github.com/alibaba/xquic">https://github.com/alibaba/xquic</a></p><p>XQUIC主要具备以下两个优势：</p><ul><li>协议设计方面：XQUIC 是按照 IETF QUIC 标准[1]进行的协议栈能力实现，在互通性方面，XQUIC 也在 IETF 开发者社区进行了比较充分的互通性验证[2]。在 QUIC V1 标准的基础之上，XQUIC 添加了<strong>对多路径传输的能力支持</strong>。</li><li>协议实现方面：XQUIC 是跨平台的 C 库实现，当前提供对Android/iOS/Linux 平台的支持。在移动端 APP 场景，XQUIC 在 Android / iOS 双端的包大小在 300～400KB 之间，相对轻量化。同时，XQUIC 也具备高性能传输能力，针对移动性场景优化也会持续进行。关于 multipath 技术演进，具体可以点击查看大淘宝技术团队与达摩院 XG 实验室联合发表的论文(<a href="https://dl.acm.org/doi/abs/10.1145/3452296.3472893)。">https://dl.acm.org/doi/abs/10.1145/3452296.3472893)。</a></li></ul><p>XQUIC 将手淘导购 RPC 的网络耗时缩减了 17.52%~20.26%，短视频/图片的上传速度提升了 22.61%，并减少了短视频下载场景下 7~16%的视频分片下载耗时。</p><h2 id="MQTT-over-QUIC：下一代物联网标准协议为消息传输场景注入新动力"><a href="#MQTT-over-QUIC：下一代物联网标准协议为消息传输场景注入新动力" class="headerlink" title="MQTT over QUIC：下一代物联网标准协议为消息传输场景注入新动力"></a>MQTT over QUIC：下一代物联网标准协议为消息传输场景注入新动力</h2><p><a href="https://cloud.tencent.com/developer/article/2061429?policyId=1004">MQTT over QUIC：下一代物联网标准协议为消息传输场景注入新动力-腾讯云开发者社区-腾讯云 2022-07-29 </a></p><h3 id="QUIC在MQTT通信场景中的应用场景"><a href="#QUIC在MQTT通信场景中的应用场景" class="headerlink" title="QUIC在MQTT通信场景中的应用场景"></a>QUIC在MQTT通信场景中的应用场景</h3><p>物联网设备通常在受限的网络环境中运行，使用TCP或MQTT等传输协议可能导致高延迟和数据包丢失。QUIC在高延迟和丢包的网络条件下表现出色，因此适用于与物联网设备的通信，提供可靠和高效的替代方案。</p><p>MQTT 是基于 TCP 的<a href="https://cloud.tencent.com/product/iothub?from_column=20065&amp;from=20065">物联网通信</a>协议，紧凑的报文结构能够在严重受限的硬件设备和低带宽、高延迟的网络上实现稳定传输；心跳机制、遗嘱消息、QoS 质量等级等诸多特性能够应对各种物联网场景。</p><p>尽管如此，由于底层 TCP 传输协议限制，某些复杂网络环境下 MQTT 协议存在固有的弊端：</p><ul><li>网络切换导致经常性连接中断</li><li>断网后重新建立连接困难：断网后操作系统释放资源较慢，且应用层无法及时感知断开状态，重连时 Server/Client 开销较大</li><li>弱网环境下数据传输受限于拥塞、丢包侦测和重传机制</li></ul><p>例如车联网用户通常会面对类似的问题：车辆可能会运行在山区、矿场、隧道等地方，当进入到信号死角或被动切换基站时会导致连接中断，频繁连接中断与较慢的连接恢复速度会导致用户体验变差。在一些对数据传输实时性和稳定性要求较高的业务，如 L4 级别的无人驾驶中，客户需要花费大量的成本来缓解这一问题。</p><p>在上述这类场景中，QUIC 低连接开销和多路径支持的特性就显示出了其优势。经过更深入的探索，我们认为 MQTT Over QUIC 可以非常好地解决这一困境 —— 基于 QUIC 0 RTT/1 RTT 重连/新建能力，能够在弱网与不固定的网络通路中有效提升用户体验。</p><h3 id="EMQX-5-0-的-MQTT-over-QUIC-实现"><a href="#EMQX-5-0-的-MQTT-over-QUIC-实现" class="headerlink" title="EMQX 5.0 的 MQTT over QUIC 实现"></a>EMQX 5.0 的 MQTT over QUIC 实现</h3><p>EMQX 目前的实现将传输层换成 QUIC Stream，由客户端发起连接和创建 Stream，EMQX 和客户端在一个双向 Stream 上实现交互。</p><p>考虑到复杂的网络环境，如果客户端因某种原因未能通过 QUIC 握手，建议客户端自动退回到传统 TCP 上，避免系统无法建立跟服务器的通信。</p><p><style>.rixyvmrxffoe{zoom:67%;}</style><img src="/2025/03/24/QUIC/image-20250330214441878.png" class="rixyvmrxffoe" alt="image-20250330214441878"></p><p>目前 EMQX 5.0 中已经实现了以下特性：</p><ul><li><strong>更高级的拥塞控制：</strong>有效降低数据丢包率，在测试中在网络波动的情况下仍能持续稳定传输数据</li><li><strong>运维友好：</strong>减少大规模重连导致的开销（时间开销、客户端/服务器性能开销），减少不必要的应用层状态迁移而引发的系统过载（0 RTT）</li><li><strong>更灵活的架构创新：</strong>比如 Direct server return (DSR，服务器直接返回模式)，只有入口/请求流量经过 LB，出口和响应流量绕过 LB 直接回到客户端，减少 LB 的瓶颈</li><li><strong>减少握手延迟 （1 RTT）</strong></li><li><strong>多路径支持，连接平滑迁移：</strong>从 4G 切换到 WIFI, 或者因为 NAT Rebinding 导致五元组发生变化，QUIC 依然可以在新的五元组上继续进行连接状态，尤其适用于网络经常性变化的移动设备</li><li><strong>更敏捷的开发部署：</strong>协议栈的实现在 userspace，能够开发快速迭代</li><li><strong>端到端加密：</strong>未加密的包头带有极少信息， 减少传输路径中中间节点的影响，带来更好的安全性和更可控的用户体验</li></ul><h3 id="更便捷的使用：NanoSDK-0-6-0"><a href="#更便捷的使用：NanoSDK-0-6-0" class="headerlink" title="更便捷的使用：NanoSDK 0.6.0"></a>更便捷的使用：NanoSDK 0.6.0</h3><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Fnanomq%2FNanoSDK%2F&amp;objectId=2061429&amp;objectType=1&amp;isNewArticle=undefined">NanoSDK</a> 0.6.0 基于 MsQuic 项目率先实现了第一个 C 语言的 MQTT over QUIC SDK。</p><p>NanoSDK 通过为 NNG 的传输层增加 QUIC 支持，使 MQTT、nanomsg 等协议能够从 TCP 转为 UDP，从而提供更好的物联网连接体验。其内部将 QUIC Stream 和 MQTT 连接映射绑定，并内置实现了 0 RTT 快速握手重连功能。</p><h2 id="AXP-QUIC：自适应X路QUIC网络传输加速"><a href="#AXP-QUIC：自适应X路QUIC网络传输加速" class="headerlink" title="AXP-QUIC：自适应X路QUIC网络传输加速"></a>AXP-QUIC：自适应X路QUIC网络传输加速</h2><p> <a href="https://cloud.tencent.com/developer/article/2190257?policyId=1004">AXP-QUIC：自适应X路QUIC网络传输加速-腾讯云开发者社区-腾讯云 2022-12-10</a></p><p>腾讯云<a href="https://cloud.tencent.com/product/im?from_column=20065&amp;from=20065">即时通信</a>IM实现了一种网络自适应的X路QUIC传输加速技术AXP-QUIC（Adaptive X-PATH QUIC），已应用于IM SDK客户端到服务端的数据传输。该技术建立了一套客户端弱网自评估模型，根据网络链路的RTT，丢包率，吞吐量，并结合主动探测，判断终端当前是否处于弱网络环境。同时将QUIC协议和多通道传输技术相结合，根据终端所处的网络环境，实时自动决定切换网络链路或使用多链路进行传输。<strong>通过AXP-QUIC技术，即时通信IM能够在70%丢包的弱网络环境下，保证消息100%可靠传输，且不大幅度增加消息延时。</strong></p><h2 id="微软-MsQUIC"><a href="#微软-MsQUIC" class="headerlink" title="微软 MsQUIC"></a>微软 MsQUIC</h2><p><a href="https://github.com/microsoft/msquic">https://github.com/microsoft/msquic</a> </p><p>MsQuic 是微软开源的一个 QUIC 协议的实现，采用 C 语言编写。核心是遵循一系列 RFC 标准，包括QUIC基础框架（RFC 9000-9002）、连接迁移（RFC 9221）以及最新的性能改进草案。该项目旨在提供一个跨平台的、通用的 QUIC 协议库，同时提供了 C++ API 的包装类，并支持与 Rust 和 C# 的互操作性。</p><ul><li><p>根据项目文档的最新更新，以下是一些主要的更新内容：</p><blockquote><p><strong>性能优化</strong>：对客户端和服务器进行了优化，以提高吞吐量和降低延迟。<br><strong>异步 IO 支持</strong>：提升数据处理效率。<br><strong>接收侧扩展（RSS）支持</strong>：增加网络数据处理能力。<br><strong>UDP 发送和接收合并支持</strong>：优化了 UDP 数据包的处理。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> PaperNote </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM SIGCOMM 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Globus Striped GridFTP Framework and Server</title>
      <link href="/2025/03/20/Globus-GridFTP/"/>
      <url>/2025/03/20/Globus-GridFTP/</url>
      
        <content type="html"><![CDATA[<p>​    GridFTP对文件传输协议的扩展定义了一种安全、可靠、高性能数据移动的通用机制。这里介绍了Globus的Striped GridFTP框架，旨在支持数据密集型工具和应用程序的建设。</p><p><a href="https://dl.acm.org/doi/10.1109/SC.2005.72">The Globus Striped GridFTP Framework and Server | Proceedings of the 2005 ACM/IEEE conference on Supercomputing</a></p><p><a href="https://www.globus.org/sites/default/files/gridftp_final.pdf">gridftp_final.pdf</a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li><p>存储在二级和三级存储系统上的数据的数量和多样性以及广域网的原始容量的迅速增加，使得至少在原则上在广域网上移动大量数据是可取的和可行的。</p></li><li><p>在实践中，协调这种转移在技术上具有挑战性。</p><blockquote><p>a. 经常需要在多个维度上利用并行性，包括（取决于上下文）存储系统，网络接口和骨干网络干线。</p><p>b.处理各种各样的失败。防火墙、并行文件系统和其他专用设备也会造成困难，因为需要在传输之前和/或之后转换数据。</p><p>由于这些和其他原因，快速、高效和稳健的广域端到端传输需要在多个级别管理复杂的系统。例如，在最近的工作中，我们需要32台以1 Gbit/s连接的主机来驱动30 Gbit/s的连接。</p></blockquote></li><li><p>有效的端到端数据传输需要一种系统方法，其中文件系统，计算机，网络接口和网络协议以集成的方式进行管理，以满足性能和鲁棒性目标。且需要被封装在易于使用和跨不同的最终系统和网络架构的便携式软件中，以便被广泛使用。 </p></li><li><p>以上考虑促使我们在这里描述的工作，这涉及到一个模块化的和可扩展的数据传输系统架构，适用于广域和高性能环境的设计，实现和评估。这个Globus striped GridFTP框架实现了对文件传输协议（FTP）的GridFTP扩展，它提供了对来自多个数据源的条带传输，故障检测和其他功能的支持。框架和在框架内构建的高性能条带服务器都是Globus Toolkit 版本4（GT 4）的一部分，并利用Globus组件来实现安全性和I/O。Globus GridFTP框架具有模块化结构，允许协调多个数据流，替换可选择的传输协议以及其他所需的功能。这些功能使我们能够在局域网和广域网上实现高比例的端到端带宽。</p></li><li><p>在<a href="https://pages.cs.wisc.edu/~bart/739/papers/planet2004.pdf">Operating System Support for Planetary-Scale Services.</a>中描述了GridFTP协议的早期实现。该实现基于WU-FTPD，并且不具有该协议的所有功能。在这里，我们讨论了一个全新的协议实现，并提供了一组广泛的性能数据的新的实现。此实现提供了第一个公开可用的条带化版本。此外，该实现基于Globus可扩展输入/输出（XIO）系统，并提供了几个新的干净接口用于修改和扩展服务器。此实现还提供对IPv6的支持。</p><blockquote><p>WU-FTPD : <strong>WU-FTPD</strong>（Washington University FTP Daemon）是 <strong>华盛顿大学开发的一款 FTP 服务器软件</strong>，用于提供 <strong>文件传输协议（FTP）服务</strong>.</p></blockquote></li></ul><h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><p>​    分布式数据的高效移动并不是什么新问题。并行I/O系统通常将对分布式数据的访问视为集体操作，集体通信操作通过协调相关活动来优化数据转换和传输。在两阶段I/O和远程I/O中，数据被读取，然后在传输之前通过进程间通信重新组织。HPF/MPI使用FALLS表示来计算有效的集群间通信调度。</p><blockquote><ol><li><p>HPF（High Performance Fortran）<br>• 一种并行编程语言，扩展自 Fortran 90，主要用于数据并行计算。<br>• 适用于分布式存储架构，常用于高性能计算（HPC）。</p></li><li><p>MPI（Message Passing Interface）<br>• 一种用于分布式计算的消息传递标准。<br>• 允许在多个计算节点之间进行数据通信，提高并行计算性能。</p></li><li>FALLS（FAmiLy of Line Segments）表示法<br>• 一种用于优化通信调度的数学模型或方法。<br>• 可能涉及将通信任务表示为线段，以优化数据流在集群中的传输。<br>• 主要目标是减少通信开销、提高并行计算效率。</li><li>集群间通信调度（Inter-cluster Communication Schedules）<br>• 在 HPC 环境下，不同计算节点或计算集群之间需要交换数据。<br>• 高效调度算法可以减少数据传输延迟、避免通信瓶颈，提高整体计算性能。</li></ol></blockquote><p>​    研究人员已经提出了许多解决方案来解决TCP 基于AIMD的拥塞控制机制的局限性。这些解决方案包括对TCP的改进，新的传输协议，如XCP，XTP 和UDP之上的可靠层。<strong>我们的系统被设计为与这样的高性能通信协议和服务质量协商系统接口</strong>。到目前为止，我们的工作<strong>主要集中在有效地使用TCP或其他传输协议的每个流的基础上</strong>。我们的系统还可以以协调的方式管理与单个传输相关联的所有流。</p><p>​    分布式并行存储系统（DPSS）是一个可动态配置的广泛分布的磁盘服务器的集合，这些服务器并行运行，以提供对大型数据集的高速随机访问。Beck等人的物流式网络也使数据的广泛分发（和复制）成为可能。我们的系统可以利用这样的系统时，单节点或站点的性能是瓶颈。</p><blockquote><p>Logistical Networking物流式网络是一种数据传输和存储优化技术，主要用于高效调度和管理大规模数据流，类似于现实世界中的物流管理。它的核心思想是：</p><ul><li>数据存储和传输的调度像物流系统一样，可以进行智能管理。</li><li>利用分布式存储和缓存（如中转节点）优化数据传输路径，提高吞吐量和可靠性。</li><li>动态优化数据流，减少网络拥塞，提高数据分发效率。</li></ul></blockquote><ul><li><p>Thain等人和Swany描述了数据移动系统，这些系统在中间节点中机会性地使用磁盘来提高端到端性能。<strong>我们的系统可用于在端到端路径中的节点之间传输数据</strong>。</p></li><li><p>BitTorrent和Slurpie允许客户端在多人同时下载同一文件时从多个来源上传文件片段。由于我们的系统支持条带化和部分文件传输，它可以用来<strong>作为这些系统中的数据传输工具</strong>，以产生良好的效果。</p></li><li><p>分布式文件系统可以用于在维护文件系统语义的同时访问远程数据。通用并行文件系统（GPFS）在广域网上实现了与我们的系统相当的性能。<strong>GridFTP旨在用于不太紧密耦合的环境中</strong>，其中文件系统语义可能既不能实现，也不可取。</p></li><li><p>Weigle和Chien的工作在目标和方法上可能与我们的最接近。他们将M到N通信问题概念化为称为复合端点的节点集。它们定义了一个API，用于定义复合端点内的发送方和接收方数据分布，并引入和评估用于计算有效通信调度的算法。他们的技术可以与GridFTP自然集成。</p></li></ul><h1 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h1><p>​    <strong>Striping</strong>：希望支持条带化数据移动操作，其中将分布在网络一端的一组计算机 或 存储系统上的数据传送到另一组远程存储系统或计算机。</p><p>​    <strong>Collective operations</strong>：希望将条带化传输视为集体操作。</p><p>​    <strong>Uniform interfaces</strong>：希望能够轻松地调整我们的系统，以支持不同的汇和源。</p><p>​    <strong>Network protocol issues</strong>：  希望支持这种TCP替代协议的办法。    </p><p>​    <strong>End-to-end performance </strong>：希望提供一个框架，在这个框架内，可以方便地应用一系列这样的端到端管理方法。</p><p>​    <strong>Diverse failure modes</strong>：集体操作、条带传输和端到端管理为增强性能提供了机会，但也引入了新的故障模式。我们的设计必须解决鲁棒性和容错性。</p><h1 id="GridFTP-Protocol"><a href="#GridFTP-Protocol" class="headerlink" title="GridFTP Protocol"></a>GridFTP Protocol</h1><p>我们采用GridFTP数据传输协议，而不是像WebDAV这样的替代方案，原因有五个：</p><ul><li>GridFTP所基于的FTP协议分离了控制和数据通道，使第三方传输成为可能；</li><li>FTP是一种广泛实现和理解的IETF标准协议，具有大量的代码和专业知识；</li><li>FTP为协议扩展提供了定义良好的体系结构，并支持动态发现特定实现所支持的扩展；</li><li>IETF已经定义了许多扩展，其中一些在当前环境中是有用的；</li><li>GridFTP增加了与我们关注的问题相关的新功能。</li></ul><blockquote><p>WebDAV（web分布式创作和版本控制）：基于 HTTP/HTTPS 的文件管理协议，用于远程创建、编辑、删除和管理文件。它扩展了 HTTP，使用户可以像操作本地文件一样，在 Web 服务器上管理文件和目录。</p></blockquote><p>以下是GridFTP关键特性的摘要。</p><ul><li><p><strong>Third-party control of data transfer.</strong>  <code>为了管理分布式社区的大型数据集，我们必须为存储服务器之间的数据传输提供经过身份验证的第三方控制。第三方操作允许一个站点的用户或应用程序启动、监视和控制两个其他站点（数据传输的源和目的地）之间的数据传输操作。</code></p></li><li><p><strong>Authentication, data integrity, data confidentiality.</strong>  <code>GridFTP支持对控制通道（RFC 2228）和数据通道（GridFTP扩展）的通用安全服务（GSS）API身份验证，并支持用户控制的数据完整性和机密性级别。数据通道验证在第三方传输中特别重要，因为连接数据通道的主机的IP地址将不同于连接在控制通道上的主机的IP地址，并且必须有某种方法来验证它是否是预期的一方。</code></p></li><li><p><strong>Striped data transfer.</strong>  <code>数据可以在多个服务器之间进行条带化或交错，如在并行文件系统或DPSS(分布式并行存储系统)磁盘缓存中。因此，GridFTP定义了支持在多个服务器之间传输分区数据的协议扩展。</code></p></li><li><p><strong>Parallel data transfer.</strong> <code>在广域链路上，在单个源和目的地之间并行使用多个TCP流可以相提高总带宽。GridFTP通过FTP命令扩展和数据通道扩展支持这种并行性。当使用并行或条带化时，GridFTP实现可以使用较长的虚拟往返时间来实现公平性。注意，条带化和并行化可以一前一后地使用，即，在参与分条传输的多个服务器中的每一个之间可能有多个TCP流打开。</code></p><blockquote><p>虚拟往返时间：当多个数据流共享同一条网络链路时，如果某些流的 RTT 非常短，它们可能会占用过多带宽，而影响其他流的公平性。GridFTP 在传输过程中人为地增加 TCP 连接的虚拟往返时间，模拟更长的网络时延，防止某些 TCP 连接因短 RTT 过快增长窗口，而导致其他连接无法获得足够带宽。</p></blockquote></li><li><p><strong>Partial file transfer.</strong> <code>某些应用程序可以从传输部分文件而不是完整文件中获益。FTP允许从指定的偏移量开始传输文件的其余部分。GridFTP**支持对任意文件区域的请求。**</code></p></li><li><p><strong>Automatic negotiation of TCP buffer/window sizes.</strong>  <code>使用TCP缓冲区/窗口大小的最佳设置可以显著提高数据传输性能。GridFTP扩展了FTP命令集和数据通道协议，以支持针对大文件和大量小文件手动设置和自动协商TCP缓冲区大小。我们的系统目前只支持手动设置TCP缓冲区大小。</code></p></li><li><p><strong>Support for reliable and restartable data transfer.</strong> <code>FTP标准包括用于重新启动失败传输的基本功能，这些功能尚未广泛实现。GridFTP利用了这些特性，并对其进行了扩展，以覆盖其新的数据通道协议。</code></p></li></ul><h1 id="Globus-Striped-GridFTP-Design"><a href="#Globus-Striped-GridFTP-Design" class="headerlink" title="Globus Striped GridFTP Design"></a>Globus Striped GridFTP Design</h1><p>Globus分条GridFTP系统的目标是：</p><ul><li><p>模块化，以便于替代机制和在不同环境和配置中的使用 ;</p></li><li><p>效率，特别是避免数据副本。正如在xKernel等系统中一样，我们通过一种架构来实现这些目标，该架构允许通过组成负责不同功能的独立模块来构建协议处理管道。</p><blockquote><p>xKernel 是一个专为网络协议研究和实验设计的<strong>微内核框架</strong>，它允许用户在一个模块化的环境中开发、测试和优化网络协议。适用于计算机网络研究、教学和协议测试，但不适合作为常规的操作系统使用。</p></blockquote></li></ul><p>实现（图1）包括三个逻辑上不同的组件：</p><ul><li><p>客户端和服务器协议解释器(PI): <code>用来处理控制通道协议(这两个功能不同，因为协议交换不对称)；</code></p></li><li><p>数据传输进程(DTP): <code>处理实际数据的访问及其通过数据通道协议的移动。</code></p></li></ul><p>​    这些组件可以以各种方式组合，以创建具有不同功能的服务器。例如，在一个进程中组合服务器PI和DTP组件可以创建传统的FTP服务器，而条带化服务器可能在群集的头节点上使用一个服务器PI，在所有其他节点上使用DTP。<code>(IPC:  Inter-Process Communication，进程间通信)</code></p><p><style>.mffzkvpxzhyx{zoom:80%;}</style><img src="/2025/03/20/Globus-GridFTP/image-20250322165249001.png" class="mffzkvpxzhyx" alt="image-20250322165249001"></p><p>​                        <code>Figure 1: Globus GridFTP architecture</code></p><p>​    DTP本身被进一步分解为一个三层流水线（图2）。</p><ul><li>数据访问模块提供了与数据源或数据接收的接口；</li><li>如果收到扩展存储/检索(ESTO/ERET)命令的请求，则数据处理模块在服务器端执行数据处理；</li><li>数据通道协议模块从数据通道读取或写入数据通道。</li></ul><p><style>.lseytykpmsyb{zoom:80%;}</style><img src="/2025/03/20/Globus-GridFTP/image-20250322171223774.png" class="lseytykpmsyb" alt="image-20250322171223774"></p><p>​                        <code>Figure 2: Globus GridFTP data transfer pipeline</code></p><h2 id="The-Protocol-Interpreter"><a href="#The-Protocol-Interpreter" class="headerlink" title="The Protocol Interpreter"></a>The Protocol Interpreter</h2><p><strong>服务器PI处理控制信道交换</strong>。</p><ul><li><p>为了让客户端联系GridFTP服务器，要么服务器PI必须作为守护进程运行并监听一个已知的端口（GridFTP为2811），要么其他服务（如inetd）必须监听该端口并配置为调用服务器PI。</p></li><li><p>客户端PI则执行其与服务器PI的协议交换。</p><blockquote><p><strong>inetd</strong>（Internet Service Daemon）是 <strong>Unix/Linux 系统上的超级服务器（Super Server）</strong>，用于<strong>管理基于 TCP/IP 的网络服务</strong>（如 FTP、Telnet、SSH、SMTP 等）。它的主要作用是监听多个端口，并在有请求时<strong>动态启动相应的服务进程</strong>，从而减少系统资源消耗。</p></blockquote></li></ul><p>​    在协议交换的准备阶段，服务器 PI 仅关注制定即将进行的传输的描述。此时不需要与DTP通信;实际上，DTP甚至不需要运行。当接收到需要DTP活动的命令时，服务器PI将传送的描述传递给它（如果需要，首先启动它），之后DTP可以自己执行传送。一旦传送请求被传递，服务器PI就简单地充当传送状态信息的中继。例如，服务器DTP可以发送性能标记、重启标记等到服务器PI，服务器PI可选地处理它们，然后将它们发送到客户机PI。</p><p>​    <strong>PI到DTP的通信是服务器内部</strong>的，因此所使用的协议可以在不影响客户端的情况下发展。</p><p>​    数据通道通信结构由数据布局控制。一般来说，如果两端的节点数量相等，则每个节点只与另一个节点通信。否则，每个发送方建立到每个接收方的连接，并基于数据偏移向每个接收方发送数据。</p><h2 id="DTP-Data-Access-Module"><a href="#DTP-Data-Access-Module" class="headerlink" title="DTP Data Access Module"></a>DTP Data Access Module</h2><p>​    此模块负责从数据源或接收端进行阅读或向数据源或接收器进行写入。它的公共接口包括传输操作（列表、发送、接收）和命令操作（例如，生成/删除目录、重命名、校验和）。可以提供该接口的不同实现。</p><h2 id="DTP-Data-Processing-Module"><a href="#DTP-Data-Processing-Module" class="headerlink" title="DTP Data Processing Module"></a>DTP Data Processing Module</h2><p>​    此模块允许服务器端数据处理，例如压缩、缩放或多个文件的动态连接。正常的（没有服务器端处理）传输是用<code>STOR &lt;filename&gt;</code>（对于put）或<code>RETR &lt;filename&gt;</code>（对于get）启动的。数据处理模块分别通过ESTO和ERET命令调用puts和gets，这两个命令都接受三个字符串作为参数：模块名、不透明模块参数和文件名。模块名用于在模块注册表中定位加载的模块。模块被传递参数字符串和文件名，并在数据传输到服务器时对数据执行任何必要的处理。</p><h2 id="DTP-Data-Channel-Protocol-Module"><a href="#DTP-Data-Channel-Protocol-Module" class="headerlink" title="DTP Data Channel Protocol Module"></a>DTP Data Channel Protocol Module</h2><p>​    该模块负责数据通道处理，即从数据通道获取数据或向数据通道发送数据所需的操作。单个服务器可以支持多个数据通道协议，在这种情况下，MODE命令用于选择要用于特定传输的协议。<code>我们使用Globus可扩展输入/输出（XIO）系统[10]作为数据通道协议模块接口，目前支持两种绑定：Stream mode TCP和Extended Block Mode TCP。</code></p><blockquote><p><strong><code>MODE</code> 命令</strong>：在不同的网络协议或操作系统环境下有不同的作用，主要用于<strong>设置数据传输模式或设备模式</strong>。</p><p>1、FTP中规范定义了三种传输模式：</p><ul><li><code>MODE S</code>(Stream mode，默认)：数据按流方式传输，没有额外的格式化或分块处理。适用于大多数 FTP 传输。</li><li><code>MODE B</code>(Block mode): 数据以块的形式传输，每个块都有标识符和校验信息。适用于高可靠性传输，较少使用。</li><li><code>MODE C</code>(Compressed mode)：采用 Lempel-Ziv 压缩算法减少数据传输量。现在几乎不用，因为现代 FTP 传输通常由外部压缩（如 <code>gzip</code>、<code>zstd</code>）或 <code>MODE Z</code>（FTP 扩展）代替。</li></ul><p>2、在 Windows/Linux 命令行中的 <code>MODE</code> 命令</p><ul><li><p>用于配置 串行端口(COM 端口)、显示模式等设备设置 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MODE COM1: BAUD=9600 PARITY=N DATA=8 STOP=1</span><br><span class="line"><span class="comment">#作用: 设置串口 `COM1` 的波特率为 `9600`、无奇偶校验（`N`）、数据位 `8`、停止位 `1`。</span></span><br></pre></td></tr></table></figure></li></ul><p>3、在 GridFTP 传输协议中的 <code>MODE</code></p><ul><li><p>扩展了FTP版本的 <code>MODE</code> 命令，比如：</p><p><code>MODE E</code>(Extended Block Mode)：允许并行传输多个数据流，提高大文件传输性能。支持错误恢复，如果某个块丢失，只需重传该块而不是整个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MODE E</span><br><span class="line">200 Extended Block Mode Enabled.</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="Security-Considerations"><a href="#Security-Considerations" class="headerlink" title="Security Considerations"></a>Security Considerations</h2><ul><li><p>Globus GridFTP设计提供控制通道请求的安全认证（强制性）和数据通道完整性和机密性（可选）。支持 GSS-API 网格安全基础设施 (GSI) 和 Kerberos 认证绑定。标准 Kerberos 不支持数据通道认证，但存在支持该功能的“用户对用户”扩展。</p></li><li><p>在这里讨论GSI。</p><ul><li><strong>建立控制通道</strong></li></ul><p>​         当客户端发起到服务器正在侦听的端口的TCP连接时，会话就建立了。第一件必须发生的事情是根据RFC 2228进行身份验证。默认情况下，客户端提供一个委托代理证书，服务器必须提供由客户端信任的 CA（证书颁发机构）签发的“host certificate”，并且该证书的可分辨名称（DN）必须以通用名称（CN）结尾，该通用名称应与服务器 IP 地址的反向 DNS 查询结果<strong>完全匹配</strong>。如果身份验证成功，则调用授权验证器来（a）验证授权，以及（b）确定应执行请求的本地用户id。如果授权成功，则控制信道已经建立。</p><ul><li><p><strong>建立数据通道</strong></p><ul><li><p>GridFTP协议要求接收方是监听方，发送方发出TCP连接。</p></li><li><p>因此，客户端向要接收数据的服务器发送PASV命令。接收器开始监听TCP端口，并相应命令将IP地址和端口信息发送给客户端。</p><blockquote><p>PASV（Passive Mode）命令是 FTP（文件传输协议） 中的一种数据传输模式。它用于让 服务器 进入被动模式，等待客户端来建立数据连接。</p></blockquote></li><li><p>然后客户端向另一个服务器发送PORT（或SPOR，用于条带端口）命令，该命令将IP/ports作为参数。此命令指示服务器启动TCP连接，并建立数据通道。</p><blockquote><p>PORT 命令是 FTP 主动模式（Active Mode）中使用的命令，它用于告诉服务器，客户端希望在特定的 IP 地址和端口上接收数据连接。</p></blockquote></li><li><p>第三方传输存在安全问题，因为接收服务器开始监听端口，但它无法知道将连接到它的服务器的IP地址。为了缓解此问题，默认要求在数据通道上进行GSI身份验证。在这种情况下，服务器执行委托，身份验证的两端必须提供用户的主题名称（不涉及主机证书）。参与传输的所有各方必须接受同一CA。</p></li><li><p>数据通道上支持加密保密性和完整性保护，但由于其成本（数量级在高速链路上并不罕见），默认情况下不启用。</p></li></ul></li></ul></li></ul><p>​    当PI和DTP在单独的进程中运行时，它们通过进程间通信链路进行通信。该链路的建立完全按照控制信道，PI充当客户端（使用委托凭证），DTP提供其主机证书。</p><h1 id="Experimental-Studies"><a href="#Experimental-Studies" class="headerlink" title="Experimental Studies"></a>Experimental Studies</h1><p>​    我们在三个设置进行实验：</p><ul><li>一个局域网（LAN ）与0.2毫秒（msec）的往返时间（RTT）和612 Mbit/s的瓶颈链路;</li><li>一个城域网（MAN）与2.2毫秒的RTT和1 Gbit/s的瓶颈链路;</li><li>一个广域网（WAN）与60毫秒的RTT和30 Gbit/s的瓶颈链路。</li></ul><p>​    在所有测试中，我们将TCP缓冲区大小设置为<code>BDP/number-of-stream</code>。</p><blockquote><p>在 TCP 传输中，<strong>带宽-时延积（BDP，Bandwidth-Delay Product）</strong> 是一个关键指标，它表示<strong>在网络传输中，保持链路充分利用所需的最大未确认数据量</strong>，即网络中的最大数据窗口</p><p>为什么设置 TCP 缓冲区大小为 <code>(BDP / number-of-streams)</code>？</p><ul><li>在高带宽、长延迟（<strong>高 BDP</strong>）网络中，例如跨数据中心传输或卫星通信，TCP 发送窗口必须足够大，以避免带宽浪费。</li><li>但是，如果我们使用<strong>多个并行流</strong>进行数据传输，每个流应该分配到合适的缓冲区大小，以均衡利用整个网络。</li><li><strong>因此，我们将总的 TCP 缓冲区大小（BDP）均分到 <code>number-of-streams</code> 个并行流</strong>，以优化传输效率并防止某个流占用过多资源。</li></ul></blockquote><h2 id="Comparison-with-Other-FTP-Servers"><a href="#Comparison-with-Other-FTP-Servers" class="headerlink" title="Comparison with Other FTP Servers"></a>Comparison with Other FTP Servers</h2><p>​    我们首先将我们的服务器与两个流行的FTP服务器WU-FTPD 和NCFTP 进行比较，在相同的条件下：没有条带化，并行或身份验证，并且处于流模式。对于磁盘IO，我们使用了64 KB的块大小。我们在图3和图4中展示了在LAN和WAN中传输大小为1、10、100和1000 MB的文件时的性能。所有数据点均为10次运行的平均值，还显示了误差条。</p><p>实验结论：</p><p>​    我们的服务器在所有情况下都实现了上级性能，并且相对于其他系统在处理较大文件时表现更好。这可能是因为我们的实现中使用了高效的异步事件处理机制。</p><img src="/2025/03/20/Globus-GridFTP/image-20250322202706721.png" class="" title="image-20250322202706721"><h2 id="Harnessing-Parallelism"><a href="#Harnessing-Parallelism" class="headerlink" title="Harnessing Parallelism"></a>Harnessing Parallelism</h2><p>​    接下来我们来看看多个流对总体实现性能的影响。图5-7显示了在LAN、MAN和WAN设置中实现的性能与数据流数量的函数关系。我们展示了四种不同情况下的数据：</p><ul><li><p><code>Iperf</code>、<code>memory-to-memory Globus(/dev/zero to /dev/null)</code>、<code>disk-to-disk Globus</code>，每个都运行在单个节点上，作为所使用的流数量的函数、 </p></li><li><p><code>Bonnie文件系统</code>基准测试，它首先在我们实验中使用的两台计算机之一上先写后读1 GB的文件。</p><p>​    对于<code>Iperf</code>和<code>memory-to-memory Globus</code>，我们运行应用程序60秒。对于<code>disk-to-disk Globus</code>测试，我们传输一个1 GB的文件。对于<code>Bonnie</code>，我们测量了发送方的读性能和接收方的写性能，并报告了两个值中较低的一个。</p></li></ul><blockquote><ul><li><p>Iperf - 网络性能测试工具</p><p>Iperf是一个 网络带宽测试工具，用于测量 TCP、UDP 和 SCTP 网络性能。它广泛用于测试网络吞吐量、丢包率、时延（延迟）和抖动（Jitter）。</p></li><li><p>Bonnie++ - 硬盘 I/O 测试工具</p><p>Bonnie++ 是一个 磁盘 I/O 性能测试工具，主要用于测量硬盘读写速度、文件系统吞吐量和 IOPS（每秒输入/输出操作数）。它适用于存储系统、RAID 设备、数据库服务器的性能测试。</p></li></ul></blockquote><p>实验结论：</p><p>​    在LAN的情况下，<code>memory-to-memory Globus</code>性能与<code>Iperf</code>相当，达到瓶颈带宽的92%; <code>disk-to-disk Globus</code>性能与<code>Bonnie</code>相当。</p><p>​    在所有情况下，最多五个流似乎能产生显著差异，之后增加流的数量显示的收益较小。在WAN的<code>disk-to-disk Globus</code>的情况下，我们看到随着数据流的增加，性能会有更多的下降。我们将这一结果归<strong>因于当使用更多流时，由于接收到的块无序，在接收器处进行了更多的“查找”操作</strong>。</p><h2 id="Striping"><a href="#Striping" class="headerlink" title="Striping"></a>Striping</h2><p>在<code>memory-to-memory</code>和<code>disk-to-disk</code>模式下测试了条带数据传输。</p><p>实验结论：    </p><ul><li><strong>在较低的速度下，增加的数据流并不等同于提高的性能，只有当我们接近瓶颈链路速度时，数据流的数量开始才有影响</strong>。</li><li>一般来说，并行流在RTT更高和丢包率更高的情况下更有效，但<strong>如果丢包率变得极端到所有流都丢失数据包的程度，我们可能会失去多个流的好处</strong>。我们的结果似乎验证了霍华德等人的结论。[31]关于并行TCP流的有效性。我们没有分析公平性或并行TCP对其他网络流的影响。</li></ul><h2 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h2><p>评估Globus GridFTP性能作为客户端数量的函数。使用DiPerf测试框架在多个服务器上部署客户端并收集性能数据。</p><p>实验结论：</p><ul><li>该服务器支持1800个并发请求，而每个请求只有70%的CPU和0.94 Mbyte内存。</li><li>此外，即使分配的内存超过物理内存（意味着正在进行分页），CPU使用率、吞吐量和响应时间也保持合理。</li><li>总吞吐量在少于100个客户端的情况下达到25 Mbyte/s，在大约600个客户端的情况下超过40 Mbyte/s。</li></ul>]]></content>
      
      
      <categories>
          
          <category> PaperNote </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM SC 2005 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+butterfly搭建</title>
      <link href="/2025/02/22/hexo-butterfly/"/>
      <url>/2025/02/22/hexo-butterfly/</url>
      
        <content type="html"><![CDATA[<p>可以在这里选择自己喜欢的风格主题：<a href="https://hexo.io">hexo官网</a></p><h1 id="搭建hexo-butterfly"><a href="#搭建hexo-butterfly" class="headerlink" title="搭建hexo+butterfly"></a>搭建hexo+butterfly</h1><p>参考资料：<a href="https://blog.csdn.net/weixin_62726289/article/details/129930237?ops_request_misc=%7B%22request%5Fid%22%3A%22e2804188084f90fd988a0406d3e11b96%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=e2804188084f90fd988a0406d3e11b96&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-129930237-null-null.142^v101^pc_search_result_base3&amp;utm_term=butterfly配置waline上传图片&amp;spm=1018.2226.3001.4187">使用 hexo + 主题 butterfly + Github 搭建个人博客_hexo-theme-butterfly-CSDN博客</a></p><h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment">#完整命令为hexo generate,用于生成静态文件</span></span><br><span class="line">hexo s <span class="comment">#完整命令为hexo server,用于启动服务器，主要用来本地预览</span></span><br><span class="line">hexo d <span class="comment">#完整命令为hexo deploy,用于将本地文件发布到github等git仓库上</span></span><br><span class="line">hexo n “my article” <span class="comment">#完整命令为hexo new,用于新建一篇名为“my article”的文章</span></span><br></pre></td></tr></table></figure><h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="发布一篇博客"><a href="#发布一篇博客" class="headerlink" title="发布一篇博客"></a>发布一篇博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;demo&quot;</span></span><br></pre></td></tr></table></figure><p>数学符号：<a href="https://blog.csdn.net/guozhenqiang19921021/article/details/71601094?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=latex拉丁字符&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-71601094.142^v101^pc_search_result_base3&amp;spm=1018.2226.3001.4187">LaTeX 各种命令，符号_c上面一撇用chinatex怎么打-CSDN博客</a></p><h2 id="基础美化"><a href="#基础美化" class="headerlink" title="基础美化"></a>基础美化</h2><p>参考资料：<a href="https://blog.csdn.net/qq_43740362/article/details/113783074?ops_request_misc=%7B%22request%5Fid%22%3A%2240282c28307dbe873861698b149400de%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=40282c28307dbe873861698b149400de&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~time_text~default-5-113783074-null-null.142^v101^pc_search_result_base3&amp;utm_term=hexo给myself设置背景&amp;spm=1018.2226.3001.4187">Butterfly美化_butterfly-vue-CSDN博客</a></p><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><h3 id="支持博客评论"><a href="#支持博客评论" class="headerlink" title="支持博客评论"></a>支持博客评论</h3><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_45882139/article/details/129963841">Waline在Butterfly主题中的应用_butterfly配置waline-CSDN博客</a></p><p><a href="https://waline.js.org/guide/get-started/">快速上手 | Waline</a></p><ul><li>需要注意的是该步骤跳转的地址即为serverURL，需要记住这个地址</li></ul><img src="/2025/02/22/hexo-butterfly/image-20250224212312505.png" class="" title="image-20250224212312505"><ul><li>评论管理<ul><li>部署完成后，请访问 <code>&lt;serverURL&gt;/ui/register</code> 进行注册。首个注册的人会被设定成管理员。</li><li>管理员登陆后，即可看到评论管理界面。在这里可以修改、标记或删除评论。</li><li>用户也可通过评论框注册账号，登陆后会跳转到自己的档案页</li></ul></li></ul><h3 id="添加表情包"><a href="#添加表情包" class="headerlink" title="添加表情包"></a>添加表情包</h3><p>可以从该仓库选择自己喜欢的表情包类型：<a href="https://github.com/walinejs/emojis">walinejs/emojis: Emojis Repo for Waline</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\myblog\themes\butterfly\layout\includes\third-party\comments\waline.pug</span><br></pre></td></tr></table></figure><p>修改上述路径下的文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emoji: [</span><br><span class="line"><span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/alus&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;https://unpkg.com/@waline/emojis@1.1.0/qq&#x27;</span>,</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure><h3 id="评论图片"><a href="#评论图片" class="headerlink" title="评论图片"></a>评论图片</h3><p>1、在<a href="https://7bu.top">去不图床</a>购买存储容量</p><p>2、去不图床购买完成之后进入Token页面，生成Token(保存此Token，因为只显示一次。)</p><p>3、修改waline.pug文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\myblog\themes\butterfly\layout\includes\third-party\comments\waline.pug</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    const waline = Fn(&#123;</span><br><span class="line">      el: el.querySelector(<span class="string">&#x27;#waline-wrap&#x27;</span>),</span><br><span class="line">      serverURL: <span class="string">&#x27;https://feifanyulu-waline.vercel.app&#x27;</span>,//</span><br><span class="line">      emoji: [</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/alus&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.1.0/qq&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/bmoji&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/tieba&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/weibo&#x27;</span>,</span><br><span class="line">      ],</span><br><span class="line">      pageview: !&#123;lazyload ? <span class="literal">false</span> : pageview&#125;,</span><br><span class="line">      dark: <span class="string">&#x27;html[data-theme=&quot;dark&quot;]&#x27;</span>,</span><br><span class="line">      comment: !&#123;lazyload ? <span class="literal">false</span> : count&#125;,</span><br><span class="line">      </span><br><span class="line">//-----------------------在文件中添加如下部分------------------------------------//</span><br><span class="line">      imageUploader: (file) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (!file) &#123;  </span><br><span class="line">            throw new Error(<span class="string">&#x27;No file provided&#x27;</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="built_in">let</span> formData = new FormData();</span><br><span class="line">          <span class="built_in">let</span> headers = new Headers();</span><br><span class="line">          formData.append(<span class="string">&#x27;file&#x27;</span>, file);</span><br><span class="line">          </span><br><span class="line">          headers.set(<span class="string">&#x27;Authorization&#x27;</span>, <span class="string">&#x27;API TOKEN&#x27;</span>);  // API TOKEN需要改成第二步复制的token，去不给的token是1234|xxxx，前面的数字和竖杠不需要，加上Bearer 变成Bearer xxxxx才能认证通过</span><br><span class="line">          headers.set(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="built_in">return</span> fetch(<span class="string">&#x27;https://7bu.top/api/v1/upload&#x27;</span>, &#123;    // 去不图床的API就是此链接，如果你用的其他图床就改成其他的</span><br><span class="line">            method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            headers: headers,</span><br><span class="line">            body: formData,</span><br><span class="line">            mode: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">          &#125;)</span><br><span class="line">            .<span class="keyword">then</span>((resp) =&gt; resp.json())</span><br><span class="line">            .<span class="keyword">then</span>((resp) =&gt; resp.data.links.url);</span><br><span class="line">        &#125;,</span><br><span class="line">//----------------------------------------------------------------------------//</span><br><span class="line">      ...option,</span><br><span class="line">      path: isShuoshuo ? path : (option &amp;&amp; option.path) || path</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_40673755/article/details/140539730?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-140539730-blog-129963841.235^v43^control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-140539730-blog-129963841.235^v43^control&amp;utm_relevant_index=5">为Hexo添加评论系统Waline并配置图床_hexo waline-CSDN博客</a></p><h1 id="遇见的问题"><a href="#遇见的问题" class="headerlink" title="遇见的问题"></a>遇见的问题</h1><h2 id="md格式的博文上传后图片无法显示"><a href="#md格式的博文上传后图片无法显示" class="headerlink" title="md格式的博文上传后图片无法显示"></a>md格式的博文上传后图片无法显示</h2><p>1、将 _config.yml 文件中的 post_asset_folder 选项设为 true；(该操作的目的就是在使用<code>hexo new xxx</code>指令新建md文档博文时，在相同的/source/posts路径下同步创建一个相同名字的<code>xxx</code>文件夹，而<code>xxx</code>文件夹就是用来存放新建md文档里的图片的)</p><p>2、使用typora编辑md格式的博文，需要对typora的设置—&gt;偏好设置中进行修改，如下：(这样我们粘贴图片到md文档的时候，typora会自动把图片再复制一份到我们上面创建的同名文件夹下)</p><img src="/2025/02/22/hexo-butterfly/image-20250224213647018.png" class="" title="image-20250224213647018"><p>参考资料：<a href="https://blog.csdn.net/lengcs/article/details/143816877?ops_request_misc=%7B%22request%5Fid%22%3A%2239167e82ce3160fc47f69925ea7bb820%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=39167e82ce3160fc47f69925ea7bb820&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-13-143816877-null-null.142^v101^pc_search_result_base3&amp;utm_term=hexo md插入图片&amp;spm=1018.2226.3001.4187">[2024] hexo图片无法加载究极解决方案_hexo图片显示不出来-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> ToolGuide </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>centos7.3部署lustre2.10.8</title>
      <link href="/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/"/>
      <url>/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>​    <a href="https://www.lustre.org/about/">About the Lustre® File System | Lustre</a></p><p>​    Lustre文件系统是一种开源并行文件系统，支持一流 HPC 模拟环境的许多要求。Lustre 文件系统诞生于卡内基梅隆大学的一个研究项目，现已发展成为支持地球上一些最强大的超级计算机的文件系统。Lustre 文件系统提供符合 POSIX 标准的文件系统接口，可以扩展到数千个客户端、PB 级存储和每秒数百 GB 的 I/O 带宽。Lustre 文件系统的关键组件是元数据服务器 （MDS）、元数据目标 （MDT）、对象存储服务器 （OSS）、对象服务器目标 （OST） 和 Lustre 客户端。</p><img src="/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/LustreComponents21.gif" class="" title="LustreComponents21"><p><a href="http://lustrefs.cn/wp-content/uploads/2023/03/Lustre_Manual_cn.pdf">Lustre_Manual_cn.pdf</a></p><p>Lustre中的角色：</p><ol><li><strong>管理服务器（Management Server, MGS）：</strong></li></ol><p>​    ● 管理整个文件系统的元信息和配置。</p><p>​    ● 硬件要求：高性能 CPU、充足的内存和可靠存储设备。</p><ol><li><strong>元数据服务器（Metadata Server, MDS）：</strong></li></ol><p>​    ● 存储文件系统的元数据（如文件名、目录结构等）。</p><p>​    ● 通常与元数据目标（Metadata Target, MDT）一起部署在 MDS 上。</p><ol><li><strong>对象存储服务器（Object Storage Server, OSS）：</strong></li></ol><p>​    ● 存储文件数据。</p><p>​    ● 每个 OSS 管理一个或多个对象存储目标（Object Storage Target, OST）。</p><ol><li><strong>客户端：</strong></li></ol><p>​    ● 连接并访问 Lustre 文件系统的计算节点</p><p><a href="https://www.hikunpeng.com/document/detail/zh/kunpengsdss/ecosystemEnable/Lustre/openmind_kunpenglustre_04_0002.html">环境要求-Lustre 2.13.0 部署指南（CentOS 8.0）-Lustre-开源使能-开发文档-鲲鹏社区</a>)</p><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><p>参考文档:</p><p><a href="https://note.youdao.com/ynoteshare/index.html?id=113224210bf5120b2731ae9e0af5ebb4&amp;type=note&amp;_time=1734593758030">Lustre 2.10安装.note</a></p><p><a href="https://blog.csdn.net/spring_color/article/details/79301167?ops_request_misc=%7B%22request%5Fid%22%3A%22d9945c8131134fab2ed7eff447d79e82%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=d9945c8131134fab2ed7eff447d79e82&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-79301167-null-null.142^v100^pc_search_result_base3&amp;utm_term=Lustre部署·centos7&amp;spm=1018.2226.3001.4187">CentOS-7 安装Lustre-2.10.1文件系统_centos7安装lustre-CSDN博客</a></p><div class="table-container"><table><thead><tr><th>节点名</th><th>节点IP</th><th>节点角色</th><th>软件版本</th></tr></thead><tbody><tr><td>cn17538</td><td>10.182.190.3</td><td>MDS、MDT、OST</td><td>系统版本：centos7.3</td></tr><tr><td>cn17539</td><td>10.182.190.4</td><td>MDT、OST</td><td>软件版本：7.2.4-el7</td></tr><tr><td>cn17540</td><td>10.182.190.5</td><td>Client</td></tr></tbody></table></div><h3 id="简单配置Linux"><a href="#简单配置Linux" class="headerlink" title="简单配置Linux"></a>简单配置Linux</h3><p>1、更新yum源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum clean all</span><br><span class="line">$ yum makecache</span><br><span class="line">$ yum update</span><br></pre></td></tr></table></figure><p>2、 安装基础包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum groupinstall <span class="string">&quot;Development Tools&quot;</span> -y</span><br><span class="line">$ yum install epel-release quilt libselinux-devel python-docutils xmlto asciidoc elfutils-libelf-devel elfutils-devel zlib-devel rng-tools binutils-devel python-devel sg3_utils newt-devel perl-ExtUtils-Embed audit-libs-devel lsof hmaccalc -y</span><br></pre></td></tr></table></figure><p>3、关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld.service</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure><h3 id="构建本地Lustre-repo库"><a href="#构建本地Lustre-repo库" class="headerlink" title="构建本地Lustre repo库"></a>构建本地Lustre repo库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/yum.repos.d/lustre.repo</span><br></pre></td></tr></table></figure><p>在lustre.repo里写入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[lustre-server]</span><br><span class="line">name=lustre-server</span><br><span class="line">baseurl=https://downloads.whamcloud.com/public/lustre/latest-2.10-release/el7/server</span><br><span class="line"><span class="comment"># exclude=*debuginfo*</span></span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">[lustre-client]</span><br><span class="line">name=lustre-client</span><br><span class="line">baseurl=https://downloads.whamcloud.com/public/lustre/latest-2.10-release/el7/client</span><br><span class="line"><span class="comment"># exclude=*debuginfo*</span></span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">[e2fsprogs-wc]</span><br><span class="line">name=e2fsprogs-wc</span><br><span class="line">baseurl=https://downloads.whamcloud.com/public/e2fsprogs/latest/el7</span><br><span class="line"><span class="comment"># exclude=*debuginfo*</span></span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>更新源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum clean all </span><br><span class="line">$ yum makecache</span><br></pre></td></tr></table></figure><p>参考文档出现如下出现问题：</p><img src="/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/image-20250225215515963.png" class="" title="image-20250225215515963"><p>解决问题：参考文档中这一部分操作写了一堆，我也看不懂，不知道什么原因，我直接在/etc/yum.repos.d中创建了lustre.repo文件，并更新了yum源，似乎没什么问题</p><h2 id="服务节点安装（MDS、OSS）"><a href="#服务节点安装（MDS、OSS）" class="headerlink" title="服务节点安装（MDS、OSS）"></a>服务节点安装（MDS、OSS）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ yum --nogpgcheck --disablerepo=* --enablerepo=e2fsprogs-wc install e2fsprogs -y</span><br><span class="line">$ yum -y install epel-release</span><br><span class="line">$ yum install http://download.zfsonlinux.org/epel/zfs-release.el7_3.noarch.rpm -y</span><br><span class="line">$ yum upgrade linux-firmware dracut -y <span class="comment"># 升级冲突包</span></span><br><span class="line">$ yum upgrade xfsprogs kmod kexec-tools -y <span class="comment"># 升级冲突包</span></span><br><span class="line">$ yum install pciutils -y</span><br><span class="line">$ yum --nogpgcheck --disablerepo=base,extras,updates --enablerepo=lustre-server install kernel kernel-devel kernel-headers kernel-tools kernel-tools-libs kernel-tools-libs-devel -y</span><br><span class="line">$ reboot</span><br><span class="line">$ yum --nogpgcheck --enablerepo=lustre-server install kmod-lustre-osd-ldiskfs lustre-dkms lustre-osd-ldiskfs-mount lustre lustre-resource-agents zfs lustre-osd-zfs-mount -y</span><br><span class="line"></span><br><span class="line">加载 ZFS 文件系统的内核模块</span><br><span class="line">$ modprobe -v zfs</span><br><span class="line">加载 Lustre 文件系统的内核模块</span><br><span class="line">$ modprobe -v lustre</span><br></pre></td></tr></table></figure><p>服务节点安装的是2.10.8版本，客户端安装2.10.8版本时发现，centos默认的内核不支持客户端安装2.10.8版本，所以客户端安装的是2.10.1版本。</p><h1 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a><strong>客户端安装</strong></h1><p>最好不要和MDS和ODS安装在一个节点上，会出现内核不兼容的问题，如果出现安装的客户端与默认的系统内核不兼容的问题，可以尝试更换系统中其他的内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum install kernel kernel-devel kernel-headers kernel-abi-whitelists kernel-tools kernel-tools-libs kernel-tools-libs-devel -y</span><br><span class="line">$ reboot</span><br><span class="line">$ yum install epel-release -y</span><br><span class="line">$ yum --nogpgcheck --enablerepo=lustre-client install lustre-client-dkms lustre-client kmod-lustre-client -y</span><br></pre></td></tr></table></figure><p>切换内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看当前系统可用内核</span><br><span class="line">$ <span class="built_in">sudo</span> awk -F\&#x27; <span class="string">&#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27;</span> /etc/grub2.cfg</span><br><span class="line">选择输出的内核编号</span><br><span class="line">$  <span class="built_in">sudo</span> grub2-set-default <span class="string">&#x27;1&#x27;</span></span><br><span class="line">$ reboot</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h1><p>​     Lustre是基于内核的分布式文件系统，而不是像其它一些用户态的分布式文件系统那样直接建立在ext3或者是ext4之上。Lustre需要对磁盘进行格式化，并且在格式化的过程中进行参数配置。</p><p>​    在 Lustre 中，MGS（Management Server） 是一个集中式的元数据服务，它负责管理整个 Lustre 文件系统的元数据。MGS 通常只在第一个 MDT 节点上配置，并且该节点会作为主 MDT 来管理所有的元数据操作。一旦配置了 MGS，Lustre 文件系统的所有 MDT节点会通过网络连接到该 MGS。因为 MGS 是唯一的，它的作用是服务所有 MDT 节点（无论你有多少个 MDT 节点）</p><h3 id="配置MDT"><a href="#配置MDT" class="headerlink" title="配置MDT"></a>配置MDT</h3><p>通过—index来对每个MDT进行标识</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、配置第一个MDS</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgs --mdt --index=0 /dev/nvme0n1p3</span><br><span class="line"> $ <span class="built_in">mkdir</span> /mnt/lustre/mdt</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p3 /mnt/lustre/mdt</span><br><span class="line"></span><br><span class="line">2、配置第二个MDS</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgsnode=10.182.190.3@tcp0 --mdt --index=1 /dev/nvme0n1p3</span><br><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre/mdt</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p3 /mnt/lustre/mdt</span><br><span class="line"> </span><br><span class="line">参数解释： </span><br><span class="line">fsname指定的是创建lustre时的文件系统名 </span><br><span class="line">mgs指定该机器为元数据服务器，即该机器为mds </span><br><span class="line">mdt指定/dev/sdb为元数据实际数据存储位置 </span><br><span class="line">至于index则指定该mgs的索引号，mgs可以设置主备模式，但mdt需要在主备mds之间共享 </span><br></pre></td></tr></table></figure><h3 id="配置OST"><a href="#配置OST" class="headerlink" title="配置OST"></a>配置OST</h3><p>通过—index来对每个OST进行标识</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、配置第一个OST</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgsnode=10.182.190.3@tcp0 --ost --index=0 /dev/nvme0n1p2</span><br><span class="line">查看是否格式化成功</span><br><span class="line">$ <span class="built_in">sudo</span> lsblk -f</span><br><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre/ost</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p2 /mnt/lustre/ost</span><br><span class="line"></span><br><span class="line">2、配置第二个OST</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgsnode=10.182.190.3@tcp0 --ost --index=1 /dev/nvme0n1p2</span><br><span class="line">查看是否格式化成功</span><br><span class="line">$ <span class="built_in">sudo</span> lsblk -f</span><br><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre/ost</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p2 /mnt/lustre/ost</span><br></pre></td></tr></table></figure><h3 id="配置Client"><a href="#配置Client" class="headerlink" title="配置Client"></a>配置Client</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre</span><br><span class="line">$ mount -t lustre 10.182.190.3@tcp:/lustrefs /mnt/lustre</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ToolGuide </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/2025/02/19/Compilation-Principle/"/>
      <url>/2025/02/19/Compilation-Principle/</url>
      
        <content type="html"><![CDATA[<p>​    程序设计语言是向人以及计算机描述计算过程的记号。例如我们所知道的这个世界依赖于程序设计语言，因为在所有计算机上运行的所有软件都是用某种程序设计语言编写的。但是，在一个程序可以运行之前，它首先需要被翻译成一种能够被计算机执行的形式，完成这项翻译工作的软件系统就是编译器。编译器可以将某种语言(源语言)编写的程序翻译成一个等价的用另外一种语言编写的程序。</p><p>​    编译器能够把源程序映射为语义上等价的目标程序，这个过程可以由两部分组成: 分析部分和综合部分；</p><ul><li>分析部分(前端)：把源程序分解成为多个组成要素，并在这些要素之上加上语法结构。然后使用这个结构来创建该源程序的一个中间表示。如果分析部分检查出源程序没有按照正确的语法构成，或者语义上不一致，它就必须提供有用的信息，使得用户可以按此进行改正。分析部分还会收集有关源程序的信息，并把信息存放在一个称为符号表的数据结构中。符号表将和中间表示形式一起传送给综合部分。</li><li>综合部分(后端)：根据中间表示和符号表中的信息来构造用户期待的目标程序。</li></ul><p>编译过程中顺序的执行了一组步骤。每个步骤把源程序的一种表示方式转换为另一种表示方式。如下图所示</p><img src="/2025/02/19/Compilation-Principle/image-20250222145903286.png" class="" title="image-20250222145903286"><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>源程序—&gt; <strong>词法分析器</strong> —&gt;记号流(token)—&gt; <strong>语法分析器</strong> —&gt;抽象语法树—&gt; <strong>语义分析器</strong> —&gt;中间表示IR</p><img src="/2025/02/19/Compilation-Principle/image-20250222124616749.png" class="" title="image-20250222124616749"><h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p>两种实现方式：</p><ul><li>手动编码，GCC、LLVM，转移图算法</li><li>词法生成器自动生成器(lex/flex/jlex)</li></ul><p>RE—&gt;NFA—&gt;DFA—&gt;词法分析器代码<br>中间算法：Thompson算法—子集构造算法—Hopcroft最小化算法</p><h3 id="正则表达式RE"><a href="#正则表达式RE" class="headerlink" title="正则表达式RE"></a>正则表达式RE</h3><p>声明式规范(正则表达式)—&gt;词法分析器<br>对于给定的字符集 $\Sigma = {c1,c2,…,cn}$<br>归纳定义：</p><ul><li>空串是正则表达式</li><li>对于任意的 <script type="math/tex">c\in\Sigma</script>，c是正则表达式</li><li>如果M和N是正则表达式，则以下也是正则表达式<ul><li>选择  M|N = {M, N}</li><li>连接  MM = {mn| m <script type="math/tex">\in</script> M, n <script type="math/tex">\in</script> N }</li><li>闭包  M* = { $\varepsilon$, M, MM, MMM, … }</li></ul></li></ul><h3 id="有限状态自动机FA"><a href="#有限状态自动机FA" class="headerlink" title="有限状态自动机FA"></a>有限状态自动机FA</h3><p>输入的字符串—&gt;FA—&gt;{yes, no} 什么样的串可以被接受</p><ul><li>确定状态有限自动机DFA<ul><li>对任意的字符，最多有一个状态可以转移</li></ul></li><li>非确定状态有限自动机NFA<ul><li>对任意的字符，有多个状态可以转移</li></ul></li></ul><h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>记号流(token)—&gt; <strong>语法分析器</strong> (语言的语法规则) —&gt; 语法树<br>语法规则：<br>上下文无关文法的定义：</p><ul><li>上下文无关文法(简称 <strong>文法</strong> )由终结符号、非终结符号、一个开始符号和一组产生式组成</li><li>终结符号是组成串的基本符号</li><li>非终结符号是表示串的集合的语法变量</li><li>某个非终结符号被指定为开始符号，这个符号表示的串集合就是这个文法生成的语言。按照惯例，首先列出来开始符号的产生式。</li><li>一个文法的产生式描述了将终结符号和非终结符号组合成串的方法。每个产生式由下列形式组成：<blockquote><p>非终结符号 —→ 零个或者多个终结符号与非终结符号组成<br>selection_statement<br>: IF ‘(‘ expression ‘)’ statement<br>| IF ‘(‘ expression ‘)’ statement ELSE statement;<br>|<br>;</p></blockquote></li></ul><p>语法分析树：过滤掉了推导过程中对非终结符号应用产生式的顺序。语法分析树的每个内部节点表示一个产生式的应用。该内部节点表示一个产生式的应用。该内部节点的标号是此产生式头中的非终结符号A；这个节点的子节点的标号从左到右组成了在推导过程中替换这个A的产生式体。</p><p>二义性：如果一个文法可以为某个句子生成多棵语法分析树，那么它就是二义性的；换句话说，二义性文法就是对同一个句子有多个最左推导或多个最右推导的文法。<br>解决方法：文法的重写</p><p>语法分析器的实现方式</p><ul><li>手工分析—递归下降分析器</li><li>自动生成器—LL(1)、LR(1)</li></ul><h3 id="自顶向下分析：从开始符号出发推导句子"><a href="#自顶向下分析：从开始符号出发推导句子" class="headerlink" title="自顶向下分析：从开始符号出发推导句子"></a>自顶向下分析：从开始符号出发推导句子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tokens[];</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">stack = [s];</span><br><span class="line"><span class="keyword">while</span> ( stack != [] )</span><br><span class="line">    <span class="keyword">if</span> ( stack[top] is a terminal t)</span><br><span class="line">        <span class="keyword">if</span> ( t==tokens[i++] )</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">backtrack</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( stack[top] is a nonterminal T )</span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">push</span>( the next right hand side of T );</span><br></pre></td></tr></table></figure><p>需要通道回溯，给分析效率带来问题；实际上编译器必须高效，需要线性时间的算法，因此引出递归下降分析和LL(1)分析；</p><p>递归下降分析算法(预测分析)</p><ul><li>每个非终结符构造一个分析函数；</li><li>用前看符号指导产生式规则的选择。</li></ul><p>自动生成<br>声明式的规范—&gt;自动生成器(antlr:LL(1)、YACC(Unix)、bison(linux))—&gt;语法分析器<br>LL(1)分析算法</p><ul><li>从左(L)向右读入程序，最左(L)推导，采用一个(1)前看符号<ul><li>分析高效(线性时间)</li><li>错误定位和诊断信息准确</li><li>有很多开源或商业的生成工具(antlr)</li></ul></li><li>基本思想：表驱动的分析算法</li><li>缺点  <ul><li>能分析的文法类型受限</li><li>往往需要文法的改写</li></ul></li></ul><h3 id="自底向上分析"><a href="#自底向上分析" class="headerlink" title="自底向上分析"></a>自底向上分析</h3><p>LR分析算法(移进-规约算法)</p><ul><li>算法运行高效，有现成的工具可用</li><li>目前最广泛的一类语法分析器的自动生成器(YACC,bison,CUP,C#yacc等)中采用的算法</li><li>移进 一个记号到栈顶上，或者</li><li>规约 栈顶上的n个符号(某产生式的右部)到左部的非终结符<ul><li>对产生式A —&gt; $\beta 1…\beta n$<ul><li>如果 $\beta n…\beta 1$在栈顶上，则弹出 $\beta n…\beta 1$ ，压入A</li></ul></li></ul></li><li>表驱动的LR分析器架构<br>点记号：为了方便标记语法分析器已经读入了多少输入，我们可以引入一个点记号；</li></ul><p>LR(0)分析算法</p><ul><li>从左(L)向右读入程序，最右(R)推导，不用前看符号来决定式的选择(0个前看符号)<ul><li>优点：容易实现</li><li>缺点：能分析的文法有限</li></ul></li></ul><p>SLR分析算法</p><ul><li>和LR(0)分析算法基本步骤相同</li><li>仅区别于对归约的处理<ul><li>对于状态i上的项目X-&gt; $\alpha ·$, 仅对y $\in$ FOLLOW(X)添加ACTION[i,y]</li></ul></li></ul><p>LR(1)分析算法</p><ul><li>基于LR(0),通过进一步判断一个前看符号，来决定是否执行规约动作<ul><li>X—&gt; $\alpha ·$归约，当且仅当y $\in$ FOLLOW(X)</li></ul></li><li>优点<ul><li>有可能减少需要归约的情况</li><li>有可能去除需要递进-归约冲突</li></ul></li><li>缺点<ul><li>仍然有冲突出现的可能</li></ul></li></ul><p>对二义性文法的处理</p><ul><li>二义性文法无法使用LR分析算法分析</li><li>有几类二义性文法很容易理解：优先级、结合性、悬空else</li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>YACC是Yet Another Compiler-Compiler缩写，在1975年首先在此基础上做了改进：例如GNU Bison，并移植到其他语言上<br>Yacc架构</p><blockquote><p>用户代码和yacc声明：可以再接下来的部分使用<br>%%<br>语法规则：上下文无关文法<br>%%<br>用户代码：用户提供的代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">yylex</span><span class="params">()</span></span>;<span class="comment">//词法分析器的接口</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%left <span class="string">&#x27;+&#x27;</span></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">exp : n</span><br><span class="line">    | exp + exp</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">n: <span class="string">&#x27;1&#x27;</span>| <span class="string">&#x27;2&#x27;</span> | <span class="string">&#x27;3&#x27;</span> |;</span><br><span class="line">%%</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">yylex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">char</span>* s)</span></span>&#123;</span><br><span class="line">   <span class="built_in">fprintf</span> (stderr, <span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">yyparse</span>(); <span class="comment">// 语法分析器的驱动函数；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法制导的翻译"><a href="#语法制导的翻译" class="headerlink" title="语法制导的翻译"></a>语法制导的翻译</h3><p>编译器在做语法分析的过程中，除了回答程序语法是否合法外，还必须完成后续工作</p><ul><li>可能得工作(包括但不限于)：类型检查、目标代码生成、中间代码生成。这些后续的工作一般可通过语法制导的翻译完成；</li><li>给每条产生式规则附加一条语义动作(一个代码片段)</li><li>语义动作产生式”归约”时执行，即由右部的值计算左部的值，以自底向上的技术为例进行讨论</li></ul><h3 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h3><p><style>.klythxkrjtlb{zoom: 40%;}</style><img src="/2025/02/19/Compilation-Principle/image.png" class="klythxkrjtlb" alt="image"><br>对于表达书而言，编译器只需要知道运算符和运算符(优先级、结合性等已经在语法分析部分处理掉了)。对于语句、函数等语言其他构造而言也一样(例如编译器不关心赋值符号是=还是:=或其他)s</p><ul><li>具体语法是语法分析器使用的语法<ul><li>必须适合于语法分析，如各种分隔符、消除左递归、提取左公因子等；</li></ul></li><li>抽象语法是用来表达语法结构的内部表示<ul><li>现代编译器一般都采用 <strong>抽象语法作为前端(词法语法分析)和后端(代码生成)的接口</strong><ul><li>程序一旦被转换为抽象语法树，则源代码即被丢弃，后续阶段只处理抽象语法树</li><li>所以抽象语法书必须编码足够多的源代码信息，例如：必须编码每个语法结构在源代码中的位置(文件、行号、列号等)</li></ul></li><li>为了定义抽象语法树，编译器需要使用实现语言来定义一组数据结构</li></ul></li></ul><h2 id="语义分析器"><a href="#语义分析器" class="headerlink" title="语义分析器"></a>语义分析器</h2><p>语义分析也称为类型检查、<strong>上下文相关分析</strong>，负责检查程序(抽象语法树)的上下文相关的属性:例如，变量使用前先进行声明、每个表达式都有合适的类型、函数调用和函数的定义一致。</p><p>抽象语法树—&gt;语义分析器(根据程序语言的语义进行判断)—&gt;中间代码</p><p>语义检查</p><p>符号表: 用来存储程序中的变量相关信息(类型、作用域、访问控制信息，处理名字空间)、应为程序中的变量规模会风大，所以必须非常高效，可以使用哈希表(节省时间、O(1)时间)、红黑树(节省空间、O(lgN)时间)等数据结构来实现。</p><p>语义分析：类型相容性、错误诊断、代码翻译</p><h1 id="中间端和后端"><a href="#中间端和后端" class="headerlink" title="中间端和后端"></a>中间端和后端</h1><p>抽象语法树—&gt;代码生成(翻译1—&gt;中间表示1—&gt;翻译2—&gt;中间表示2—&gt;更多的翻译和中间表示)—&gt;汇编</p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>负责把源程序翻译成”目标机器”上的代码，两个重要任务:</p><ul><li>给源程序的数据分配计算资源<ul><li>源程序的数据：全局变量、局部变量、动态分配等</li><li>机器计算资源：寄存器、数据区、代码区、栈区、堆区</li><li>根据程序的特点和编译器的设计目标，合理的为数据分配计算机资源，例如：变量放在内存里还是寄存器里？</li></ul></li><li>给源程序的代码选择指令<ul><li>源程序的代码：表达式运算、语句、函数等</li><li>机器指令：算术运算、比较、跳转、函数调用返回</li><li>用机器指令实现高层代码的语义：等价性、对机器指令集体系结构(ISA的熟悉)</li></ul></li></ul><p>两种不同的ISA上的代码生成技术</p><ul><li>栈计算机stack<ul><li>历史：在上世纪70年代有很多的栈式计算机，但是因为效率低下已经逐渐退出历史舞台；</li><li>给栈式计算机生产代码是最容易的；</li><li>仍然有很多栈式的虚拟机：Pascal P code、java virtual machine(JVM)…..</li></ul></li><li>寄存器计算机Reg<ul><li>寄存器计算机是目前最流行的机器体系结构之一，效率很高，机器体系结构规整</li><li>机器基于寄存器架构：<ul><li>经典的有16、32或更多个寄存器，所有操作都在寄存器中进行</li><li>访存都通过load/store进行，内存不能直接运算</li></ul></li></ul></li></ul><h2 id="中间代码的地位和作用"><a href="#中间代码的地位和作用" class="headerlink" title="中间代码的地位和作用"></a>中间代码的地位和作用</h2><p>为什么划分不同的中间表示？</p><p>编译器工程上的考虑</p><ul><li>阶段划分：把整个编译过程划分为不同的阶段</li><li>任务分解：每个阶段只处理翻译过程的一个步骤</li><li>代码工程：代码更容易实现、出错、维护和演进</li></ul><p>程序分析和代码优化的需求：两者都和程序的中间表示密切相关，许多优化在特定的中间表示上才可以或才容易进行；</p><p>现代编译器中几种常见的重要中间表示(Intermediate Representation，IR)：三地址码、控制流图、静态单赋值形式；</p><p>在中间表示上做程序分析的理论和技术：控制流分析、数据流分析</p><ul><li><h5 id="三地址码"><a href="#三地址码" class="headerlink" title="三地址码"></a>三地址码</h5><ul><li><p><strong>每条指令有三项操作数</strong>，因此叫做三地址码。每条指令通常会有一个目标地址（存储结果的变量或临时变量），以及两个源地址（操作数）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y op z</span><br></pre></td></tr></table></figure></li><li><p>给每个中间变量和计算结果命名后没有复合表达式</p></li><li><p>只有最基本的控制流，没有各种控制结构(if、do、for…)，只有goto、call等</p></li><li><p>所以三地址码可以看成是抽象的指令集，可以看成是一个通用的RISC</p></li><li><p>程序的控制流信息是隐式的，可以做进一步的控制流分析</p><p><style>.sdkwekhcoldi{zoom:80%;}</style><img src="/2025/02/19/Compilation-Principle/image-20250221171039051.png" class="sdkwekhcoldi" alt="image-20250221171039051"></p></li></ul></li><li><h5 id="控制流分析"><a href="#控制流分析" class="headerlink" title="控制流分析"></a>控制流分析</h5><ul><li><p>是更加精细的三地址码</p></li><li><p>程序的控制流图表示带来了很多好处</p><ul><li>控制流分析：对于很多程序分析来说，程序的内部结构很重要；经典问题：程序中是否存在循环？</li><li>可以进一步进行其他分析：例如数据流分析；经典问题：程序第5行的变量x可能的值是什么？</li></ul><img src="/2025/02/19/Compilation-Principle/image-20250221205441500.png" class="" title="image-20250221205441500"></li><li><p>现代编译器的早期阶段就会倾向于做控制流分析，方便后续阶段的分析</p></li><li><p>基本块：是一个语句的序列，从第一条执行到最后一条，不能从中间进入和退出(即跳转指令只能出现在最后)</p></li><li><p>控制流图：控制流图是一个有向图G=(V,E)；节点V是基本块，边E是基本块之间的跳转关系</p><img src="/2025/02/19/Compilation-Principle/image-20250221193740043.png" class="" title="image-20250221193740043"></li><li><p>可以直接从抽象语法树生成：如果高层语言具有特别规整控制流结构的话较容易；也可以先生成三地址码，然后继续生成控制流图：</p><ul><li>对于像C这样的语言更加合适，包含像goto这样的非结构化的控制流语句；</li><li>更加通用(阶段划分)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List_t stms;               <span class="comment">// 三地址码中所有语句</span></span><br><span class="line">List_t blocks = &#123;&#125;；       <span class="comment">//控制流图中的所有基本块</span></span><br><span class="line">Block_t b = <span class="built_in">Block_fresh</span>();   <span class="comment">//一个初始的空的基本块</span></span><br><span class="line"><span class="built_in">scan_stms</span>()</span><br><span class="line">    foreach(s in stms)</span><br><span class="line">    <span class="keyword">if</span> (s is <span class="string">&quot;Label L&quot;</span>)    <span class="comment">// s是标号</span></span><br><span class="line">            b.label = L;</span><br><span class="line"><span class="keyword">else</span> (s is some jump)  <span class="comment">//s是跳转</span></span><br><span class="line">            b.j = s;</span><br><span class="line">blocks U= &#123;b&#125;;</span><br><span class="line">b = <span class="built_in">Block_fresh</span>();</span><br><span class="line"><span class="keyword">else</span>                 <span class="comment">// s是普通指令</span></span><br><span class="line">            b.stms U= &#123;s&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>标准的图论算法都可以用在控制流图的操作上：各种遍历算法、生成树、必经节点结构等等；</li><li>图节点的顺序有重要的应用：拓扑序、逆拓扑序、近似拓扑序等等；</li></ul><ul><li><h5 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h5><ul><li>常量传播优化</li><li>通过对程序代码进行静态分析，得到关于程序数据相关的保守信息，必须保证程序分析的结果是安全的</li><li>根据优化的目标不同，需要进行的数据流分析也不同<ul><li><strong>到达定义分析</strong>：对每个变量的使用点，有哪些定义可以到达？(即该变量的值是在哪儿赋值的)<ul><li>数据流方程</li></ul></li><li><strong>活性分析</strong>：在代码生成的讨论中，机器只有有限多个寄存器，寄存器分配优化需要进行活性分析</li></ul></li></ul></li></ul><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>代码优化是对被优化的程序进行的一种语义保持(程序的可观察行为不能改变)的变换，变换的目的是让程序能够比变换前更小、更快、cache行为更好、更节能等等；</p><h5 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h5><ul><li><p>一般在抽象语法树阶段做优化</p></li><li><p>局部的、流不敏感的</p></li><li><p>常量折叠、代数优化、死代码删除等</p><ul><li><p>常量折叠：在编译期间计算表达式的值，可以在整型、布尔型、浮点型等数据类型上进行；容易实现、可以在语法树或者中间表示上进行，通常被实现成公共子函数被其他优化调用；</p><blockquote><p>例如：a=3+5 ==&gt; a=8</p><p>例如：if(true&amp;&amp;false) ==&gt;if(false)</p><p>必须要很小心遵守语言的语义，例如：考虑溢出或异常  oxffffffff+1==&gt;0 ???</p></blockquote></li><li><p>代数化简：利用代数系统的性质对程序进行化简</p><blockquote><p>示例：</p><p>a = 0+b ==&gt; a = b</p><p>a = 1*b ==&gt; a = b</p><p>2*a ==&gt; a + a          （强度削弱）</p><p>2*a ==&gt; a&lt;&lt;1             (强度削弱)</p><p>同样必须非常仔细的处理语义，例如：(i - j) + (i - j) ==&gt; i + i - j - j</p></blockquote></li><li><p>死代码(不可达代码)删除：静态移除程序中不可执行的代码</p><blockquote><p>示例:</p><p>if (false)</p><p>​       s1;</p><p>else s2;       ==&gt; s2;</p><p>在控制流图中也可以进行这些优化，但在早期做这些优化可以简单中后端</p></blockquote></li></ul></li></ul><h5 id="中期优化"><a href="#中期优化" class="headerlink" title="中期优化"></a>中期优化</h5><ul><li><p>在中间表示上进行代码优化</p></li><li><p>全局的、流敏感的</p></li><li><p>依赖于具体所使用的中间表示：</p><ul><li><p>控制流图(CFG)、控制依赖图(CDG)、静态单赋值形式(SSA)、后续传递风格(CPS)等</p></li><li><p>共同的特点是需要进行程序分析，优化是全局进行的，而不是局部，通用的模式是：程序分析—&gt;程序重写</p></li><li><p>优化的一般模式: </p><img src="/2025/02/19/Compilation-Principle/image-20250222141611890.png" class="" title="image-20250222141611890"></li></ul></li><li><p>常量传播、拷贝传播、死代码删除、公共字表达式删除等</p><ul><li><p>常量传播：先进行到达定义分析,例如x=1,y=2,z=x+y —&gt; x=1,y=2,z=3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量传播算法</span></span><br><span class="line"><span class="built_in">const_prop</span>(Prog_t p)</span><br><span class="line">    <span class="comment">//第一个：程序分析</span></span><br><span class="line">    <span class="built_in">reaching_definition</span>(p)</span><br><span class="line">    <span class="comment">//第二步：程序改写</span></span><br><span class="line">    foreach(stm s in p: y = x1,...,xn)</span><br><span class="line">    foreach(use of xi in s)</span><br><span class="line">    <span class="keyword">if</span>(the reaching def of xi is unique: xi = n )</span><br><span class="line">                y = x1,...,xi<span class="number">-1</span>,n,xi<span class="number">+1</span>,...,xn</span><br></pre></td></tr></table></figure></li><li><p>拷贝传播: 例如: x=y ;a=x —&gt; a=y</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量传播算法</span></span><br><span class="line"><span class="built_in">const_prop</span>(Prog_t p)</span><br><span class="line">    <span class="comment">//第一个：程序分析</span></span><br><span class="line">    <span class="built_in">reaching_definition</span>(p)</span><br><span class="line">    <span class="comment">//第二步：程序改写</span></span><br><span class="line">    foreach(stm s in p: y = x1,...,xn)</span><br><span class="line">    foreach(use of xi in s)</span><br><span class="line">    <span class="keyword">if</span>(the reaching def of xi is unique: xi = z )</span><br><span class="line">                y = x1,...,xi<span class="number">-1</span>,z,xi<span class="number">+1</span>,...,xn</span><br></pre></td></tr></table></figure></li><li><p>死代码删除：需要进行活性分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//死代码删除算法</span></span><br><span class="line"><span class="built_in">dead_code</span>(Prog_t p)</span><br><span class="line">    <span class="comment">//第一步：程序分析</span></span><br><span class="line">    <span class="built_in">liveness_analysis</span>(p);</span><br><span class="line"><span class="comment">//第二步：程序改写</span></span><br><span class="line">foreach(stm s in p:y = ...)</span><br><span class="line">        <span class="keyword">if</span>(y is NOT in live_out[s])</span><br><span class="line">            <span class="built_in">remove</span>(s);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h5><ul><li>在后端(汇编代码级)进行</li><li>寄存器分配、指令调度、窥孔优化等</li></ul><h1 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a><strong>Reflection</strong></h1><p>OS：终于把本科分流后欠下的债还了一部分了。谁懂啊，从计算机专业分流去了大数据后，研究生阶段又跑来搞系统；</p><p>参考资源：</p><p>网课：<a href="https://www.bilibili.com/video/BV17W41187gL?spm_id_from=333.788.videopod.episodes&amp;vd_source=93e39300d281cef5ad42ab13d4028d04">编译原理 — 中科大_哔哩哔哩_bilibili</a></p><p>书籍：<a href="https://gitee.com/Microservice-Framework/E-book.git">编译原理(原书第2版)(龙书) .pdf · 曾彩军/E-book - Gitee.com</a></p>]]></content>
      
      
      <categories>
          
          <category> CS基础 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
