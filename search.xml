<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>centos7.3部署lustre2.10.8</title>
      <link href="/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/"/>
      <url>/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/</url>
      
        <content type="html"><![CDATA[<p><img src="./centos7-3部署lustre2-10-8/头像.jpg" alt="图片"></p><img src="/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/image.png" class="" title="image">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Compilation Principle</title>
      <link href="/2025/02/19/Compilation-Principle/"/>
      <url>/2025/02/19/Compilation-Principle/</url>
      
        <content type="html"><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>源程序—&gt; <strong>词法分析器</strong> —&gt;记号流(token)—&gt; <strong>语法分析器</strong> —&gt;抽象语法树—&gt; <strong>语义分析器</strong> —&gt;中间表示</p><h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p>两种实现方式：</p><ul><li>手动编码，GCC、LLVM，转移图算法</li><li>词法生成器自动生成器(lex/flex/jlex)</li></ul><p>RE—&gt;NFA—&gt;DFA—&gt;词法分析器代码<br>中间算法：Thompson算法—子集构造算法—Hopcroft最小化算法</p><h3 id="正则表达式RE"><a href="#正则表达式RE" class="headerlink" title="正则表达式RE"></a>正则表达式RE</h3><p>声明式规范(正则表达式)—&gt;词法分析器<br>对于给定的字符集 $\Sigma = {c1,c2,…,cn}$<br>归纳定义：</p><ul><li>空串是正则表达式</li><li>对于任意的 <script type="math/tex">c\in\Sigma</script>，c是正则表达式</li><li>如果M和N是正则表达式，则以下也是正则表达式<ul><li>选择  M|N = {M, N}</li><li>连接  MM = {mn| m <script type="math/tex">\in</script> M, n <script type="math/tex">\in</script> N }</li><li>闭包  M* = { $\varepsilon$, M, MM, MMM, … }</li></ul></li></ul><h3 id="有限状态自动机FA"><a href="#有限状态自动机FA" class="headerlink" title="有限状态自动机FA"></a>有限状态自动机FA</h3><p>输入的字符串—&gt;FA—&gt;{yes, no} 什么样的串可以被接受</p><ul><li>确定状态有限自动机DFA<ul><li>对任意的字符，最多有一个状态可以转移</li></ul></li><li>非确定状态有限自动机NFA<ul><li>对任意的字符，有多个状态可以转移</li></ul></li></ul><h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>记号流(token)—&gt; <strong>语法分析器</strong> (语言的语法规则) —&gt; 语法树<br>语法规则：<br>上下文无关文法的定义：</p><ul><li>上下文无关文法(简称 <strong>文法</strong> )由终结符号、非终结符号、一个开始符号和一组产生式组成</li><li>终结符号是组成串的基本符号</li><li>非终结符号是表示串的集合的语法变量</li><li>某个非终结符号被指定为开始符号，这个符号表示的串集合就是这个文法生成的语言。按照惯例，首先列出来开始符号的产生式。</li><li>一个文法的产生式描述了将终结符号和非终结符号组合成串的方法。每个产生式由下列形式组成：<blockquote><p>非终结符号 —→ 零个或者多个终结符号与非终结符号组成<br>selection_statement<br>: IF ‘(‘ expression ‘)’ statement<br>| IF ‘(‘ expression ‘)’ statement ELSE statement;<br>|<br>;</p></blockquote></li></ul><p>语法分析树：过滤掉了推导过程中对非终结符号应用产生式的顺序。语法分析树的每个内部节点表示一个产生式的应用。该内部节点表示一个产生式的应用。该内部节点的标号是此产生式头中的非终结符号A；这个节点的子节点的标号从左到右组成了在推导过程中替换这个A的产生式体。</p><p>二义性：如果一个文法可以为某个句子生成多棵语法分析树，那么它就是二义性的；换句话说，二义性文法就是对同一个句子有多个最左推导或多个最右推导的文法。<br>解决方法：文法的重写</p><p>语法分析器的实现方式</p><ul><li>手工分析—递归下降分析器</li><li>自动生成器—LL(1)、LR(1)</li></ul><h3 id="自顶向下分析：从开始符号出发推导句子"><a href="#自顶向下分析：从开始符号出发推导句子" class="headerlink" title="自顶向下分析：从开始符号出发推导句子"></a>自顶向下分析：从开始符号出发推导句子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tokens[];</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">stack = [s];</span><br><span class="line"><span class="keyword">while</span> ( stack != [] )</span><br><span class="line">    <span class="keyword">if</span> ( stack[top] is a terminal t)</span><br><span class="line">        <span class="keyword">if</span> ( t==tokens[i++] )</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">backtrack</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( stack[top] is a nonterminal T )</span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">push</span>( the next right hand side of T );</span><br></pre></td></tr></table></figure><p>需要通道回溯，给分析效率带来问题；实际上编译器必须高效，需要线性时间的算法，因此引出递归下降分析和LL(1)分析；</p><p>递归下降分析算法(预测分析)</p><ul><li>每个非终结符构造一个分析函数；</li><li>用前看符号指导产生式规则的选择。</li></ul><p>自动生成<br>声明式的规范—&gt;自动生成器(antlr:LL(1)、YACC(Unix)、bison(linux))—&gt;语法分析器<br>LL(1)分析算法</p><ul><li>从左(L)向右读入程序，最左(L)推导，采用一个(1)前看符号<ul><li>分析高效(线性时间)</li><li>错误定位和诊断信息准确</li><li>有很多开源或商业的生成工具(antlr)</li></ul></li><li>基本思想：表驱动的分析算法</li><li>缺点  <ul><li>能分析的文法类型受限</li><li>往往需要文法的改写</li></ul></li></ul><h3 id="自底向上分析"><a href="#自底向上分析" class="headerlink" title="自底向上分析"></a>自底向上分析</h3><p>LR分析算法(移进-规约算法)</p><ul><li>算法运行高效，有现成的工具可用</li><li>目前最广泛的一类语法分析器的自动生成器(YACC,bison,CUP,C#yacc等)中采用的算法</li><li>移进 一个记号到栈顶上，或者</li><li>规约 栈顶上的n个符号(某产生式的右部)到左部的非终结符<ul><li>对产生式A —&gt; $\beta 1…\beta n$<ul><li>如果 $\beta n…\beta 1$在栈顶上，则弹出 $\beta n…\beta 1$ ，压入A</li></ul></li></ul></li><li>表驱动的LR分析器架构<br>点记号：为了方便标记语法分析器已经读入了多少输入，我们可以引入一个点记号；</li></ul><p>LR(0)分析算法</p><ul><li>从左(L)向右读入程序，最右(R)推导，不用前看符号来决定式的选择(0个前看符号)<ul><li>优点：容易实现</li><li>缺点：能分析的文法有限</li></ul></li></ul><p>SLR分析算法</p><ul><li>和LR(0)分析算法基本步骤相同</li><li>仅区别于对归约的处理<ul><li>对于状态i上的项目X-&gt; $\alpha ·$, 仅对y $\in$ FOLLOW(X)添加ACTION[i,y]</li></ul></li></ul><p>LR(1)分析算法</p><ul><li>基于LR(0),通过进一步判断一个前看符号，来决定是否执行规约动作<ul><li>X—&gt; $\alpha ·$归约，当且仅当y $\in$ FOLLOW(X)</li></ul></li><li>优点<ul><li>有可能减少需要归约的情况</li><li>有可能去除需要递进-归约冲突</li></ul></li><li>缺点<ul><li>仍然有冲突出现的可能</li></ul></li></ul><p>对二义性文法的处理</p><ul><li>二义性文法无法使用LR分析算法分析</li><li>有几类二义性文法很容易理解：优先级、结合性、悬空else</li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>YACC是Yet Another Compiler-Compiler缩写，在1975年首先在此基础上做了改进：例如GNU Bison，并移植到其他语言上<br>Yacc架构</p><blockquote><p>用户代码和yacc声明：可以再接下来的部分使用<br>%%<br>语法规则：上下文无关文法<br>%%<br>用户代码：用户提供的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">yylex</span><span class="params">()</span></span>;<span class="comment">//词法分析器的接口</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%left <span class="string">&#x27;+&#x27;</span></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">exp : n</span><br><span class="line">    | exp + exp</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">n: <span class="string">&#x27;1&#x27;</span>| <span class="string">&#x27;2&#x27;</span> | <span class="string">&#x27;3&#x27;</span> |;</span><br><span class="line">%%</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">yylex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">char</span>* s)</span></span>&#123;</span><br><span class="line">   <span class="built_in">fprintf</span> (stderr, <span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">yyparse</span>(); <span class="comment">// 语法分析器的驱动函数；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="语法制导的翻译"><a href="#语法制导的翻译" class="headerlink" title="语法制导的翻译"></a>语法制导的翻译</h3><p>编译器在做语法分析的过程中，除了回答程序语法是否合法外，还必须完成后续工作</p><ul><li>可能得工作(包括但不限于)：类型检查、目标代码生成、中间代码生成。这些后续的工作一般可通过语法制导的翻译完成；</li><li>给每条产生式规则附加一条语义动作(一个代码片段)</li><li>语义动作产生式”归约”时执行，即由右部的值计算左部的值，以自底向上的技术为例进行讨论</li></ul></blockquote><h3 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h3><p><style>.pwuwaeswenih{zoom: 40%;}</style><img src="/2025/02/19/Compilation-Principle/image.png" class="pwuwaeswenih" alt="image"><br>对于表达书而言，编译器只需要知道运算符和运算符(优先级、结合性等已经在语法分析部分处理掉了)。对于语句、函数等语言其他构造而言也一样(例如编译器不关心赋值符号是=还是:=或其他)s</p><ul><li>具体语法是语法分析器使用的语法<ul><li>必须适合于语法分析，如各种分隔符、消除左递归、提取左公因子等；</li></ul></li><li>抽象语法是用来表达语法结构的内部表示<ul><li>现代编译器一般都采用 <strong>抽象语法作为前端(词法语法分析)和后端(代码生成)的接口</strong><ul><li>程序一旦被转换为抽象语法树，则源代码即被丢弃，后续阶段只处理抽象语法树</li><li>所以抽象语法书必须编码足够多的源代码信息，例如：必须编码每个语法结构在源代码中的位置(文件、行号、列号等)</li></ul></li><li>为了定义抽象语法树，编译器需要使用实现语言来定义一组数据结构</li></ul></li></ul><h2 id="语义分析器"><a href="#语义分析器" class="headerlink" title="语义分析器"></a>语义分析器</h2><p>语义分析也称为类型检查、上下文相关分析，负责检查程序(抽象语法树)的上下文相关的属性:例如，变量使用前先进行声明、每个表达式都有合适的类型、函数调用和函数的定义一致</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TrackFM:Far-out Compiler Support for a Far Memory World</title>
      <link href="/2025/02/19/TrackFM-Far-out-Compiler-Support-for-a-Far-Memory-World/"/>
      <url>/2025/02/19/TrackFM-Far-out-Compiler-Support-for-a-Far-Memory-World/</url>
      
        <content type="html"><![CDATA[<p>Large memoryworkloads with favorable locality ofreference<br>can benefit by extending the memory hierarchy across ma-<br>chines. Systems that enable such far memory configurations<br>can improve application performance and overall memory<br>utilization in a cluster. There are two current alternatives<br>for software-based far memory: kernel-based and library-<br>based. Kernel-based approaches sacrifice performance to<br>achieve programmer transparency, while library-based ap-<br>proaches sacrifice programmer transparency to achieve per-<br>formance. We argue for a novel third approach, the compiler-<br>based approach, which sacrifices neither performance nor<br>programmer transparency. Modern compiler analysis and<br>transformation techniques, combined with a suitable tightly-<br>coupled runtime system, enable this approach. We describe<br>the design, implementation, and evaluation of TrackFM, a<br>new compiler-based far memory system. Through extensive<br>benchmarking, we demonstrate that TrackFM outperforms<br>kernel-based approaches by up to 2× while retaining their<br>programmer transparency, and that TrackFM can perform<br>similarly to a state-of-the-art library-based system (within<br>10%). The application is merely recompiled to reap these<br>benefits.</p>]]></content>
      
      
      <categories>
          
          <category> PaperNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud computing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/18/hello-world/"/>
      <url>/2025/02/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
