<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>The Globus Striped GridFTP Framework and Server</title>
      <link href="/2025/03/20/Globus-GridFTP/"/>
      <url>/2025/03/20/Globus-GridFTP/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li><p>存储在二级和三级存储系统上的数据的数量和多样性以及广域网的原始容量的迅速增加，使得至少在原则上在广域网上移动大量数据是可取的和可行的。</p></li><li><p>在实践中，协调这种转移在技术上具有挑战性。</p><blockquote><p>a. 经常需要在多个维度上利用并行性，包括（取决于上下文）存储系统，网络接口和骨干网络干线。</p><p>b.处理各种各样的失败。防火墙、并行文件系统和其他专用设备也会造成困难，因为需要在传输之前和/或之后转换数据。</p><p>由于这些和其他原因，快速、高效和稳健的广域端到端传输需要在多个级别管理复杂的系统。例如，在最近的工作中，我们需要32台以1 Gbit/s连接的主机来驱动30 Gbit/s的连接。</p></blockquote></li><li><p>有效的端到端数据传输需要一种系统方法，其中文件系统，计算机，网络接口和网络协议以集成的方式进行管理，以满足性能和鲁棒性目标。且需要被封装在易于使用和跨不同的最终系统和网络架构的便携式软件中，以便被广泛使用。</p></li><li><p>以上考虑促使我们在这里描述的工作，这涉及到一个模块化的和可扩展的数据传输系统架构，适用于广域和高性能环境的设计，实现和评估。这个Globus striped GridFTP框架实现了对文件传输协议（FTP）的GridFTP扩展，它提供了对来自多个数据源的条带传输，故障检测和其他功能的支持。框架和在框架内构建的高性能条带服务器都是Globus Toolkit 版本4（GT 4）的一部分，并利用Globus组件来实现安全性和I/O。Globus GridFTP框架具有模块化结构，允许协调多个数据流，替换可选择的传输协议以及其他所需的功能。这些功能使我们能够在局域网和广域网上实现高比例的端到端带宽。</p></li><li><p>在<a href="https://pages.cs.wisc.edu/~bart/739/papers/planet2004.pdf">Operating System Support for Planetary-Scale Services.</a>中描述了GridFTP协议的早期实现。该实现基于WU-FTPD，并且不具有该协议的所有功能。在这里，我们讨论了一个全新的协议实现，并提供了一组广泛的性能数据的新的实现。此实现提供了第一个公开可用的条带化版本。此外，该实现基于Globus可扩展输入/输出（XIO）系统，并提供了几个新的干净接口用于修改和扩展服务器。此实现还提供对IPv6的支持。</p><blockquote><p>WU-FTPD : <strong>WU-FTPD</strong>（Washington University FTP Daemon）是 <strong>华盛顿大学开发的一款 FTP 服务器软件</strong>，用于提供 <strong>文件传输协议（FTP）服务</strong>.</p></blockquote></li></ul><h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><p>​    分布式数据的高效移动并不是什么新问题。并行I/O系统通常将对分布式数据的访问视为集体操作，集体通信操作通过协调相关活动来优化数据转换和传输。在两阶段I/O和远程I/O中，数据被读取，然后在传输之前通过进程间通信重新组织。HPF/MPI使用FALLS表示来计算有效的集群间通信调度。</p><blockquote><ol><li><p>HPF（High Performance Fortran）<br>• 一种并行编程语言，扩展自 Fortran 90，主要用于数据并行计算。<br>• 适用于分布式存储架构，常用于高性能计算（HPC）。</p></li><li><p>MPI（Message Passing Interface）<br>• 一种用于分布式计算的消息传递标准。<br>• 允许在多个计算节点之间进行数据通信，提高并行计算性能。</p></li><li>FALLS（FAmiLy of Line Segments）表示法<br>• 一种用于优化通信调度的数学模型或方法。<br>• 可能涉及将通信任务表示为线段，以优化数据流在集群中的传输。<br>• 主要目标是减少通信开销、提高并行计算效率。</li><li>集群间通信调度（Inter-cluster Communication Schedules）<br>• 在 HPC 环境下，不同计算节点或计算集群之间需要交换数据。<br>• 高效调度算法可以减少数据传输延迟、避免通信瓶颈，提高整体计算性能。</li></ol></blockquote><p>​    研究人员已经提出了许多解决方案来解决TCP 基于AIMD的拥塞控制机制的局限性。这些解决方案包括对TCP的改进，新的传输协议，如XCP，XTP 和UDP之上的可靠层。<strong>我们的系统被设计为与这样的高性能通信协议和服务质量协商系统接口</strong>。到目前为止，我们的工作<strong>主要集中在有效地使用TCP或其他传输协议的每个流的基础上</strong>。我们的系统还可以以协调的方式管理与单个传输相关联的所有流。</p><p>​    分布式并行存储系统（DPSS）是一个可动态配置的广泛分布的磁盘服务器的集合，这些服务器并行运行，以提供对大型数据集的高速随机访问。Beck等人的物流式网络也使数据的广泛分发（和复制）成为可能。我们的系统可以利用这样的系统时，单节点或站点的性能是瓶颈。</p><blockquote><p>Logistical Networking物流式网络是一种数据传输和存储优化技术，主要用于高效调度和管理大规模数据流，类似于现实世界中的物流管理。它的核心思想是：</p><ul><li>数据存储和传输的调度像物流系统一样，可以进行智能管理。</li><li>利用分布式存储和缓存（如中转节点）优化数据传输路径，提高吞吐量和可靠性。</li><li>动态优化数据流，减少网络拥塞，提高数据分发效率。</li></ul></blockquote><ul><li><p>Thain等人和Swany描述了数据移动系统，这些系统在中间节点中机会性地使用磁盘来提高端到端性能。<strong>我们的系统可用于在端到端路径中的节点之间传输数据</strong>。</p></li><li><p>BitTorrent和Slurpie允许客户端在多人同时下载同一文件时从多个来源上传文件片段。由于我们的系统支持条带化和部分文件传输，它可以用来<strong>作为这些系统中的数据传输工具</strong>，以产生良好的效果。</p></li><li><p>分布式文件系统可以用于在维护文件系统语义的同时访问远程数据。通用并行文件系统（GPFS）在广域网上实现了与我们的系统相当的性能。<strong>GridFTP旨在用于不太紧密耦合的环境中</strong>，其中文件系统语义可能既不能实现，也不可取。</p></li><li><p>Weigle和Chien的工作在目标和方法上可能与我们的最接近。他们将M到N通信问题概念化为称为复合端点的节点集。它们定义了一个API，用于定义复合端点内的发送方和接收方数据分布，并引入和评估用于计算有效通信调度的算法。他们的技术可以与GridFTP自然集成。</p></li></ul><h1 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h1><p>​    <strong>Striping</strong>：希望支持条带化数据移动操作，其中将分布在网络一端的一组计算机 或 存储系统上的数据传送到另一组远程存储系统或计算机。</p><p>​    <strong>Collective operations</strong>：希望将条带化传输视为集体操作。</p><p>​    <strong>Uniform interfaces</strong>：希望能够轻松地调整我们的系统，以支持不同的汇和源。</p><p>​    <strong>Network protocol issues</strong>：  希望支持这种TCP替代协议的办法。    </p><p>​    <strong>End-to-end performance </strong>：希望提供一个框架，在这个框架内，可以方便地应用一系列这样的端到端管理方法。</p><p>​    <strong>Diverse failure modes</strong>：集体操作、条带传输和端到端管理为增强性能提供了机会，但也引入了新的故障模式。我们的设计必须解决鲁棒性和容错性。</p><h1 id="GridFTP-Protocol"><a href="#GridFTP-Protocol" class="headerlink" title="GridFTP Protocol"></a>GridFTP Protocol</h1><p>我们采用GridFTP数据传输协议，而不是像WebDAV这样的替代方案，原因有五个：</p><ul><li>GridFTP所基于的FTP协议分离了控制和数据通道，使第三方传输成为可能；</li><li>FTP是一种广泛实现和理解的IETF标准协议，具有大量的代码和专业知识；</li><li>FTP为协议扩展提供了定义良好的体系结构，并支持动态发现特定实现所支持的扩展；</li><li>IETF已经定义了许多扩展，其中一些在当前环境中是有用的；</li><li>GridFTP增加了与我们关注的问题相关的新功能。</li></ul><blockquote><p>WebDAV（web分布式创作和版本控制）：基于 HTTP/HTTPS 的文件管理协议，用于远程创建、编辑、删除和管理文件。它扩展了 HTTP，使用户可以像操作本地文件一样，在 Web 服务器上管理文件和目录。</p></blockquote><p>以下是GridFTP关键特性的摘要。</p><ul><li><p><strong>Third-party control of data transfer.</strong>  <code>为了管理分布式社区的大型数据集，我们必须为存储服务器之间的数据传输提供经过身份验证的第三方控制。第三方操作允许一个站点的用户或应用程序启动、监视和控制两个其他站点（数据传输的源和目的地）之间的数据传输操作。</code></p></li><li><p><strong>Authentication, data integrity, data confidentiality.</strong>  <code>GridFTP支持对控制通道（RFC 2228）和数据通道（GridFTP扩展）的通用安全服务（GSS）API身份验证，并支持用户控制的数据完整性和机密性级别。数据通道验证在第三方传输中特别重要，因为连接数据通道的主机的IP地址将不同于连接在控制通道上的主机的IP地址，并且必须有某种方法来验证它是否是预期的一方。</code></p></li><li><p><strong>Striped data transfer.</strong>  <code>数据可以在多个服务器之间进行条带化或交错，如在并行文件系统或DPSS(分布式并行存储系统)磁盘缓存中。因此，GridFTP定义了支持在多个服务器之间传输分区数据的协议扩展。</code></p></li><li><p><strong>Parallel data transfer.</strong> <code>在广域链路上，在单个源和目的地之间并行使用多个TCP流可以相提高总带宽。GridFTP通过FTP命令扩展和数据通道扩展支持这种并行性。当使用并行或条带化时，GridFTP实现可以使用较长的虚拟往返时间来实现公平性。注意，条带化和并行化可以一前一后地使用，即，在参与分条传输的多个服务器中的每一个之间可能有多个TCP流打开。</code></p><blockquote><p>虚拟往返时间：当多个数据流共享同一条网络链路时，如果某些流的 RTT 非常短，它们可能会占用过多带宽，而影响其他流的公平性。GridFTP 在传输过程中人为地增加 TCP 连接的虚拟往返时间，模拟更长的网络时延，防止某些 TCP 连接因短 RTT 过快增长窗口，而导致其他连接无法获得足够带宽。</p></blockquote></li><li><p><strong>Partial file transfer.</strong> <code>某些应用程序可以从传输部分文件而不是完整文件中获益。FTP允许从指定的偏移量开始传输文件的其余部分。GridFTP**支持对任意文件区域的请求。**</code></p></li><li><p><strong>Automatic negotiation of TCP buffer/window sizes.</strong>  <code>使用TCP缓冲区/窗口大小的最佳设置可以显著提高数据传输性能。GridFTP扩展了FTP命令集和数据通道协议，以支持针对大文件和大量小文件手动设置和自动协商TCP缓冲区大小。我们的系统目前只支持手动设置TCP缓冲区大小。</code></p></li><li><p><strong>Support for reliable and restartable data transfer.</strong> <code>FTP标准包括用于重新启动失败传输的基本功能，这些功能尚未广泛实现。GridFTP利用了这些特性，并对其进行了扩展，以覆盖其新的数据通道协议。</code></p></li></ul><h1 id="Globus-Striped-GridFTP-Design"><a href="#Globus-Striped-GridFTP-Design" class="headerlink" title="Globus Striped GridFTP Design"></a>Globus Striped GridFTP Design</h1><p>Globus分条GridFTP系统的目标是：</p><ul><li><p>模块化，以便于替代机制和在不同环境和配置中的使用 ;</p></li><li><p>效率，特别是避免数据副本。正如在xKernel等系统中一样，我们通过一种架构来实现这些目标，该架构允许通过组成负责不同功能的独立模块来构建协议处理管道。</p><blockquote><p>xKernel 是一个专为网络协议研究和实验设计的<strong>微内核框架</strong>，它允许用户在一个模块化的环境中开发、测试和优化网络协议。适用于计算机网络研究、教学和协议测试，但不适合作为常规的操作系统使用。</p></blockquote></li></ul><p>实现（图1）包括三个逻辑上不同的组件：</p><ul><li><p>客户端和服务器协议解释器(PI): <code>用来处理控制通道协议(这两个功能不同，因为协议交换不对称)；</code></p></li><li><p>数据传输进程(DTP): <code>处理实际数据的访问及其通过数据通道协议的移动。</code></p></li></ul><p>​    这些组件可以以各种方式组合，以创建具有不同功能的服务器。例如，在一个进程中组合服务器PI和DTP组件可以创建传统的FTP服务器，而条带化服务器可能在群集的头节点上使用一个服务器PI，在所有其他节点上使用DTP。<code>(IPC:  Inter-Process Communication，进程间通信)</code></p><p><style>.ttyujnnlxnlx{zoom:80%;}</style><img src="/2025/03/20/Globus-GridFTP/image-20250322165249001.png" class="ttyujnnlxnlx" alt="image-20250322165249001"></p><p>​                        <code>Figure 1: Globus GridFTP architecture</code></p><p>​    DTP本身被进一步分解为一个三层流水线（图2）。</p><ul><li>数据访问模块提供了与数据源或数据接收的接口；</li><li>如果收到扩展存储/检索(ESTO/ERET)命令的请求，则数据处理模块在服务器端执行数据处理；</li><li>数据通道协议模块从数据通道读取或写入数据通道。</li></ul><p><style>.ymgluplkyblj{zoom:80%;}</style><img src="/2025/03/20/Globus-GridFTP/image-20250322171223774.png" class="ymgluplkyblj" alt="image-20250322171223774"></p><p>​                        <code>Figure 2: Globus GridFTP data transfer pipeline</code></p><h2 id="The-Protocol-Interpreter"><a href="#The-Protocol-Interpreter" class="headerlink" title="The Protocol Interpreter"></a>The Protocol Interpreter</h2><p><strong>服务器PI处理控制信道交换</strong>。</p><ul><li><p>为了让客户端联系GridFTP服务器，要么服务器PI必须作为守护进程运行并监听一个已知的端口（GridFTP为2811），要么其他服务（如inetd）必须监听该端口并配置为调用服务器PI。</p></li><li><p>客户端PI则执行其与服务器PI的协议交换。</p><blockquote><p><strong>inetd</strong>（Internet Service Daemon）是 <strong>Unix/Linux 系统上的超级服务器（Super Server）</strong>，用于<strong>管理基于 TCP/IP 的网络服务</strong>（如 FTP、Telnet、SSH、SMTP 等）。它的主要作用是监听多个端口，并在有请求时<strong>动态启动相应的服务进程</strong>，从而减少系统资源消耗。</p></blockquote></li></ul><p>​    在协议交换的准备阶段，服务器 PI 仅关注制定即将进行的传输的描述。此时不需要与DTP通信;实际上，DTP甚至不需要运行。当接收到需要DTP活动的命令时，服务器PI将传送的描述传递给它（如果需要，首先启动它），之后DTP可以自己执行传送。一旦传送请求被传递，服务器PI就简单地充当传送状态信息的中继。例如，服务器DTP可以发送性能标记、重启标记等到服务器PI，服务器PI可选地处理它们，然后将它们发送到客户机PI。</p><p>​    <strong>PI到DTP的通信是服务器内部</strong>的，因此所使用的协议可以在不影响客户端的情况下发展。</p><p>​    数据通道通信结构由数据布局控制。一般来说，如果两端的节点数量相等，则每个节点只与另一个节点通信。否则，每个发送方建立到每个接收方的连接，并基于数据偏移向每个接收方发送数据。</p><h2 id="DTP-Data-Access-Module"><a href="#DTP-Data-Access-Module" class="headerlink" title="DTP Data Access Module"></a>DTP Data Access Module</h2><p>​    此模块负责从数据源或接收端进行阅读或向数据源或接收器进行写入。它的公共接口包括传输操作（列表、发送、接收）和命令操作（例如，生成/删除目录、重命名、校验和）。可以提供该接口的不同实现。</p><h2 id="DTP-Data-Processing-Module"><a href="#DTP-Data-Processing-Module" class="headerlink" title="DTP Data Processing Module"></a>DTP Data Processing Module</h2><p>​    此模块允许服务器端数据处理，例如压缩、缩放或多个文件的动态连接。正常的（没有服务器端处理）传输是用<code>STOR &lt;filename&gt;</code>（对于put）或<code>RETR &lt;filename&gt;</code>（对于get）启动的。数据处理模块分别通过ESTO和ERET命令调用puts和gets，这两个命令都接受三个字符串作为参数：模块名、不透明模块参数和文件名。模块名用于在模块注册表中定位加载的模块。模块被传递参数字符串和文件名，并在数据传输到服务器时对数据执行任何必要的处理。</p><h2 id="DTP-Data-Channel-Protocol-Module"><a href="#DTP-Data-Channel-Protocol-Module" class="headerlink" title="DTP Data Channel Protocol Module"></a>DTP Data Channel Protocol Module</h2><p>​    该模块负责数据通道处理，即从数据通道获取数据或向数据通道发送数据所需的操作。单个服务器可以支持多个数据通道协议，在这种情况下，MODE命令用于选择要用于特定传输的协议。<code>我们使用Globus可扩展输入/输出（XIO）系统[10]作为数据通道协议模块接口，目前支持两种绑定：Stream mode TCP和Extended Block Mode TCP。</code></p><blockquote><p><strong><code>MODE</code> 命令</strong>：在不同的网络协议或操作系统环境下有不同的作用，主要用于<strong>设置数据传输模式或设备模式</strong>。</p><p>1、FTP中规范定义了三种传输模式：</p><ul><li><code>MODE S</code>(Stream mode，默认)：数据按流方式传输，没有额外的格式化或分块处理。适用于大多数 FTP 传输。</li><li><code>MODE B</code>(Block mode): 数据以块的形式传输，每个块都有标识符和校验信息。适用于高可靠性传输，较少使用。</li><li><code>MODE C</code>(Compressed mode)：采用 Lempel-Ziv 压缩算法减少数据传输量。现在几乎不用，因为现代 FTP 传输通常由外部压缩（如 <code>gzip</code>、<code>zstd</code>）或 <code>MODE Z</code>（FTP 扩展）代替。</li></ul><p>2、在 Windows/Linux 命令行中的 <code>MODE</code> 命令</p><ul><li><p>用于配置 串行端口(COM 端口)、显示模式等设备设置 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MODE COM1: BAUD=9600 PARITY=N DATA=8 STOP=1</span><br><span class="line"><span class="comment">#作用: 设置串口 `COM1` 的波特率为 `9600`、无奇偶校验（`N`）、数据位 `8`、停止位 `1`。</span></span><br></pre></td></tr></table></figure></li></ul><p>3、在 GridFTP 传输协议中的 <code>MODE</code></p><ul><li><p>扩展了FTP版本的 <code>MODE</code> 命令，比如：</p><p><code>MODE E</code>(Extended Block Mode)：允许并行传输多个数据流，提高大文件传输性能。支持错误恢复，如果某个块丢失，只需重传该块而不是整个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MODE E</span><br><span class="line">200 Extended Block Mode Enabled.</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="Security-Considerations"><a href="#Security-Considerations" class="headerlink" title="Security Considerations"></a>Security Considerations</h2><ul><li><p>Globus GridFTP设计提供控制通道请求的安全认证（强制性）和数据通道完整性和机密性（可选）。支持 GSS-API 网格安全基础设施 (GSI) 和 Kerberos 认证绑定。标准 Kerberos 不支持数据通道认证，但存在支持该功能的“用户对用户”扩展。</p></li><li><p>在这里讨论GSI。</p><ul><li><strong>建立控制通道</strong></li></ul><p>​         当客户端发起到服务器正在侦听的端口的TCP连接时，会话就建立了。第一件必须发生的事情是根据RFC 2228进行身份验证。默认情况下，客户端提供一个委托代理证书，服务器必须提供由客户端信任的 CA（证书颁发机构）签发的“host certificate”，并且该证书的可分辨名称（DN）必须以通用名称（CN）结尾，该通用名称应与服务器 IP 地址的反向 DNS 查询结果<strong>完全匹配</strong>。如果身份验证成功，则调用授权验证器来（a）验证授权，以及（b）确定应执行请求的本地用户id。如果授权成功，则控制信道已经建立。</p><ul><li><p><strong>建立数据通道</strong></p><ul><li><p>GridFTP协议要求接收方是监听方，发送方发出TCP连接。</p></li><li><p>因此，客户端向要接收数据的服务器发送PASV命令。接收器开始监听TCP端口，并相应命令将IP地址和端口信息发送给客户端。</p><blockquote><p>PASV（Passive Mode）命令是 FTP（文件传输协议） 中的一种数据传输模式。它用于让 服务器 进入被动模式，等待客户端来建立数据连接。</p></blockquote></li><li><p>然后客户端向另一个服务器发送PORT（或SPOR，用于条带端口）命令，该命令将IP/ports作为参数。此命令指示服务器启动TCP连接，并建立数据通道。</p><blockquote><p>PORT 命令是 FTP 主动模式（Active Mode）中使用的命令，它用于告诉服务器，客户端希望在特定的 IP 地址和端口上接收数据连接。</p></blockquote></li><li><p>第三方传输存在安全问题，因为接收服务器开始监听端口，但它无法知道将连接到它的服务器的IP地址。为了缓解此问题，默认要求在数据通道上进行GSI身份验证。在这种情况下，服务器执行委托，身份验证的两端必须提供用户的主题名称（不涉及主机证书）。参与传输的所有各方必须接受同一CA。</p></li><li><p>数据通道上支持加密保密性和完整性保护，但由于其成本（数量级在高速链路上并不罕见），默认情况下不启用。</p></li></ul></li></ul></li></ul><p>​    当PI和DTP在单独的进程中运行时，它们通过进程间通信链路进行通信。该链路的建立完全按照控制信道，PI充当客户端（使用委托凭证），DTP提供其主机证书。</p><h1 id="Experimental-Studies"><a href="#Experimental-Studies" class="headerlink" title="Experimental Studies"></a>Experimental Studies</h1><p>​    我们在三个设置进行实验：</p><ul><li>一个局域网（LAN ）与0.2毫秒（msec）的往返时间（RTT）和612 Mbit/s的瓶颈链路;</li><li>一个城域网（MAN）与2.2毫秒的RTT和1 Gbit/s的瓶颈链路;</li><li>一个广域网（WAN）与60毫秒的RTT和30 Gbit/s的瓶颈链路。</li></ul><p>​    在所有测试中，我们将TCP缓冲区大小设置为<code>BDP/number-of-stream</code>。</p><blockquote><p>在 TCP 传输中，<strong>带宽-时延积（BDP，Bandwidth-Delay Product）</strong> 是一个关键指标，它表示<strong>在网络传输中，保持链路充分利用所需的最大未确认数据量</strong>，即网络中的最大数据窗口</p><p>为什么设置 TCP 缓冲区大小为 <code>(BDP / number-of-streams)</code>？</p><ul><li>在高带宽、长延迟（<strong>高 BDP</strong>）网络中，例如跨数据中心传输或卫星通信，TCP 发送窗口必须足够大，以避免带宽浪费。</li><li>但是，如果我们使用<strong>多个并行流</strong>进行数据传输，每个流应该分配到合适的缓冲区大小，以均衡利用整个网络。</li><li><strong>因此，我们将总的 TCP 缓冲区大小（BDP）均分到 <code>number-of-streams</code> 个并行流</strong>，以优化传输效率并防止某个流占用过多资源。</li></ul></blockquote><h2 id="Comparison-with-Other-FTP-Servers"><a href="#Comparison-with-Other-FTP-Servers" class="headerlink" title="Comparison with Other FTP Servers"></a>Comparison with Other FTP Servers</h2><p>​    我们首先将我们的服务器与两个流行的FTP服务器WU-FTPD 和NCFTP 进行比较，在相同的条件下：没有条带化，并行或身份验证，并且处于流模式。对于磁盘IO，我们使用了64 KB的块大小。我们在图3和图4中展示了在LAN和WAN中传输大小为1、10、100和1000 MB的文件时的性能。所有数据点均为10次运行的平均值，还显示了误差条。</p><p>实验结论：</p><p>​    我们的服务器在所有情况下都实现了上级性能，并且相对于其他系统在处理较大文件时表现更好。这可能是因为我们的实现中使用了高效的异步事件处理机制。</p><img src="/2025/03/20/Globus-GridFTP/image-20250322202706721.png" class="" title="image-20250322202706721"><h2 id="Harnessing-Parallelism"><a href="#Harnessing-Parallelism" class="headerlink" title="Harnessing Parallelism"></a>Harnessing Parallelism</h2><p>​    接下来我们来看看多个流对总体实现性能的影响。图5-7显示了在LAN、MAN和WAN设置中实现的性能与数据流数量的函数关系。我们展示了四种不同情况下的数据：</p><ul><li><p><code>Iperf</code>、<code>memory-to-memory Globus(/dev/zero to /dev/null)</code>、<code>disk-to-disk Globus</code>，每个都运行在单个节点上，作为所使用的流数量的函数、 </p></li><li><p><code>Bonnie文件系统</code>基准测试，它首先在我们实验中使用的两台计算机之一上先写后读1 GB的文件。</p><p>​    对于<code>Iperf</code>和<code>memory-to-memory Globus</code>，我们运行应用程序60秒。对于<code>disk-to-disk Globus</code>测试，我们传输一个1 GB的文件。对于<code>Bonnie</code>，我们测量了发送方的读性能和接收方的写性能，并报告了两个值中较低的一个。</p></li></ul><blockquote><ul><li><p>Iperf - 网络性能测试工具</p><p>Iperf是一个 网络带宽测试工具，用于测量 TCP、UDP 和 SCTP 网络性能。它广泛用于测试网络吞吐量、丢包率、时延（延迟）和抖动（Jitter）。</p></li><li><p>Bonnie++ - 硬盘 I/O 测试工具</p><p>Bonnie++ 是一个 磁盘 I/O 性能测试工具，主要用于测量硬盘读写速度、文件系统吞吐量和 IOPS（每秒输入/输出操作数）。它适用于存储系统、RAID 设备、数据库服务器的性能测试。</p></li></ul></blockquote><p>实验结论：</p><p>​    在LAN的情况下，<code>memory-to-memory Globus</code>性能与<code>Iperf</code>相当，达到瓶颈带宽的92%; <code>disk-to-disk Globus</code>性能与<code>Bonnie</code>相当。</p><p>​    在所有情况下，最多五个流似乎能产生显著差异，之后增加流的数量显示的收益较小。在WAN的<code>disk-to-disk Globus</code>的情况下，我们看到随着数据流的增加，性能会有更多的下降。我们将这一结果归<strong>因于当使用更多流时，由于接收到的块无序，在接收器处进行了更多的“查找”操作</strong>。</p><h2 id="Striping"><a href="#Striping" class="headerlink" title="Striping"></a>Striping</h2><p>在<code>memory-to-memory</code>和<code>disk-to-disk</code>模式下测试了条带数据传输。</p><p>实验结论：    </p><ul><li><strong>在较低的速度下，增加的数据流并不等同于提高的性能，只有当我们接近瓶颈链路速度时，数据流的数量开始才有影响</strong>。</li><li>一般来说，并行流在RTT更高和丢包率更高的情况下更有效，但<strong>如果丢包率变得极端到所有流都丢失数据包的程度，我们可能会失去多个流的好处</strong>。我们的结果似乎验证了霍华德等人的结论。[31]关于并行TCP流的有效性。我们没有分析公平性或并行TCP对其他网络流的影响。</li></ul><h2 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h2><p>评估Globus GridFTP性能作为客户端数量的函数。使用DiPerf测试框架在多个服务器上部署客户端并收集性能数据。</p><p>实验结论：</p><ul><li>该服务器支持1800个并发请求，而每个请求只有70%的CPU和0.94 Mbyte内存。</li><li>此外，即使分配的内存超过物理内存（意味着正在进行分页），CPU使用率、吞吐量和响应时间也保持合理。</li><li>总吞吐量在少于100个客户端的情况下达到25 Mbyte/s，在大约600个客户端的情况下超过40 Mbyte/s。</li></ul>]]></content>
      
      
      <categories>
          
          <category> PaperNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo+butterfly搭建</title>
      <link href="/2025/02/22/hexo-butterfly/"/>
      <url>/2025/02/22/hexo-butterfly/</url>
      
        <content type="html"><![CDATA[<p>可以在这里选择自己喜欢的风格主题：<a href="https://hexo.io">hexo官网</a></p><h1 id="搭建hexo-butterfly"><a href="#搭建hexo-butterfly" class="headerlink" title="搭建hexo+butterfly"></a>搭建hexo+butterfly</h1><p>参考资料：<a href="https://blog.csdn.net/weixin_62726289/article/details/129930237?ops_request_misc=%7B%22request%5Fid%22%3A%22e2804188084f90fd988a0406d3e11b96%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=e2804188084f90fd988a0406d3e11b96&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-129930237-null-null.142^v101^pc_search_result_base3&amp;utm_term=butterfly配置waline上传图片&amp;spm=1018.2226.3001.4187">使用 hexo + 主题 butterfly + Github 搭建个人博客_hexo-theme-butterfly-CSDN博客</a></p><h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment">#完整命令为hexo generate,用于生成静态文件</span></span><br><span class="line">hexo s <span class="comment">#完整命令为hexo server,用于启动服务器，主要用来本地预览</span></span><br><span class="line">hexo d <span class="comment">#完整命令为hexo deploy,用于将本地文件发布到github等git仓库上</span></span><br><span class="line">hexo n “my article” <span class="comment">#完整命令为hexo new,用于新建一篇名为“my article”的文章</span></span><br></pre></td></tr></table></figure><h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="发布一篇博客"><a href="#发布一篇博客" class="headerlink" title="发布一篇博客"></a>发布一篇博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;demo&quot;</span></span><br></pre></td></tr></table></figure><p>数学符号：<a href="https://blog.csdn.net/guozhenqiang19921021/article/details/71601094?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=latex拉丁字符&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-71601094.142^v101^pc_search_result_base3&amp;spm=1018.2226.3001.4187">LaTeX 各种命令，符号_c上面一撇用chinatex怎么打-CSDN博客</a></p><h2 id="基础美化"><a href="#基础美化" class="headerlink" title="基础美化"></a>基础美化</h2><p>参考资料：<a href="https://blog.csdn.net/qq_43740362/article/details/113783074?ops_request_misc=%7B%22request%5Fid%22%3A%2240282c28307dbe873861698b149400de%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=40282c28307dbe873861698b149400de&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~time_text~default-5-113783074-null-null.142^v101^pc_search_result_base3&amp;utm_term=hexo给myself设置背景&amp;spm=1018.2226.3001.4187">Butterfly美化_butterfly-vue-CSDN博客</a></p><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><h3 id="支持博客评论"><a href="#支持博客评论" class="headerlink" title="支持博客评论"></a>支持博客评论</h3><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_45882139/article/details/129963841">Waline在Butterfly主题中的应用_butterfly配置waline-CSDN博客</a></p><p><a href="https://waline.js.org/guide/get-started/">快速上手 | Waline</a></p><ul><li>需要注意的是该步骤跳转的地址即为serverURL，需要记住这个地址</li></ul><img src="/2025/02/22/hexo-butterfly/image-20250224212312505.png" class="" title="image-20250224212312505"><ul><li>评论管理<ul><li>部署完成后，请访问 <code>&lt;serverURL&gt;/ui/register</code> 进行注册。首个注册的人会被设定成管理员。</li><li>管理员登陆后，即可看到评论管理界面。在这里可以修改、标记或删除评论。</li><li>用户也可通过评论框注册账号，登陆后会跳转到自己的档案页</li></ul></li></ul><h3 id="添加表情包"><a href="#添加表情包" class="headerlink" title="添加表情包"></a>添加表情包</h3><p>可以从该仓库选择自己喜欢的表情包类型：<a href="https://github.com/walinejs/emojis">walinejs/emojis: Emojis Repo for Waline</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\myblog\themes\butterfly\layout\includes\third-party\comments\waline.pug</span><br></pre></td></tr></table></figure><p>修改上述路径下的文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emoji: [</span><br><span class="line"><span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/alus&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;https://unpkg.com/@waline/emojis@1.1.0/qq&#x27;</span>,</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure><h3 id="评论图片"><a href="#评论图片" class="headerlink" title="评论图片"></a>评论图片</h3><p>1、在<a href="https://7bu.top">去不图床</a>购买存储容量</p><p>2、去不图床购买完成之后进入Token页面，生成Token(保存此Token，因为只显示一次。)</p><p>3、修改waline.pug文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\myblog\themes\butterfly\layout\includes\third-party\comments\waline.pug</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    const waline = Fn(&#123;</span><br><span class="line">      el: el.querySelector(<span class="string">&#x27;#waline-wrap&#x27;</span>),</span><br><span class="line">      serverURL: <span class="string">&#x27;https://feifanyulu-waline.vercel.app&#x27;</span>,//</span><br><span class="line">      emoji: [</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/alus&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.1.0/qq&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/bmoji&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/tieba&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://unpkg.com/@waline/emojis@1.2.0/weibo&#x27;</span>,</span><br><span class="line">      ],</span><br><span class="line">      pageview: !&#123;lazyload ? <span class="literal">false</span> : pageview&#125;,</span><br><span class="line">      dark: <span class="string">&#x27;html[data-theme=&quot;dark&quot;]&#x27;</span>,</span><br><span class="line">      comment: !&#123;lazyload ? <span class="literal">false</span> : count&#125;,</span><br><span class="line">      </span><br><span class="line">//-----------------------在文件中添加如下部分------------------------------------//</span><br><span class="line">      imageUploader: (file) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (!file) &#123;  </span><br><span class="line">            throw new Error(<span class="string">&#x27;No file provided&#x27;</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="built_in">let</span> formData = new FormData();</span><br><span class="line">          <span class="built_in">let</span> headers = new Headers();</span><br><span class="line">          formData.append(<span class="string">&#x27;file&#x27;</span>, file);</span><br><span class="line">          </span><br><span class="line">          headers.set(<span class="string">&#x27;Authorization&#x27;</span>, <span class="string">&#x27;API TOKEN&#x27;</span>);  // API TOKEN需要改成第二步复制的token，去不给的token是1234|xxxx，前面的数字和竖杠不需要，加上Bearer 变成Bearer xxxxx才能认证通过</span><br><span class="line">          headers.set(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="built_in">return</span> fetch(<span class="string">&#x27;https://7bu.top/api/v1/upload&#x27;</span>, &#123;    // 去不图床的API就是此链接，如果你用的其他图床就改成其他的</span><br><span class="line">            method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            headers: headers,</span><br><span class="line">            body: formData,</span><br><span class="line">            mode: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">          &#125;)</span><br><span class="line">            .<span class="keyword">then</span>((resp) =&gt; resp.json())</span><br><span class="line">            .<span class="keyword">then</span>((resp) =&gt; resp.data.links.url);</span><br><span class="line">        &#125;,</span><br><span class="line">//----------------------------------------------------------------------------//</span><br><span class="line">      ...option,</span><br><span class="line">      path: isShuoshuo ? path : (option &amp;&amp; option.path) || path</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_40673755/article/details/140539730?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-140539730-blog-129963841.235^v43^control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-140539730-blog-129963841.235^v43^control&amp;utm_relevant_index=5">为Hexo添加评论系统Waline并配置图床_hexo waline-CSDN博客</a></p><h1 id="遇见的问题"><a href="#遇见的问题" class="headerlink" title="遇见的问题"></a>遇见的问题</h1><h2 id="md格式的博文上传后图片无法显示"><a href="#md格式的博文上传后图片无法显示" class="headerlink" title="md格式的博文上传后图片无法显示"></a>md格式的博文上传后图片无法显示</h2><p>1、将 _config.yml 文件中的 post_asset_folder 选项设为 true；(该操作的目的就是在使用<code>hexo new xxx</code>指令新建md文档博文时，在相同的/source/posts路径下同步创建一个相同名字的<code>xxx</code>文件夹，而<code>xxx</code>文件夹就是用来存放新建md文档里的图片的)</p><p>2、使用typora编辑md格式的博文，需要对typora的设置—&gt;偏好设置中进行修改，如下：(这样我们粘贴图片到md文档的时候，typora会自动把图片再复制一份到我们上面创建的同名文件夹下)</p><img src="/2025/02/22/hexo-butterfly/image-20250224213647018.png" class="" title="image-20250224213647018"><p>参考资料：<a href="https://blog.csdn.net/lengcs/article/details/143816877?ops_request_misc=%7B%22request%5Fid%22%3A%2239167e82ce3160fc47f69925ea7bb820%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=39167e82ce3160fc47f69925ea7bb820&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-13-143816877-null-null.142^v101^pc_search_result_base3&amp;utm_term=hexo md插入图片&amp;spm=1018.2226.3001.4187">[2024] hexo图片无法加载究极解决方案_hexo图片显示不出来-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> ToolGuide </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>centos7.3部署lustre2.10.8</title>
      <link href="/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/"/>
      <url>/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>​    <a href="https://www.lustre.org/about/">About the Lustre® File System | Lustre</a></p><p>​    Lustre文件系统是一种开源并行文件系统，支持一流 HPC 模拟环境的许多要求。Lustre 文件系统诞生于卡内基梅隆大学的一个研究项目，现已发展成为支持地球上一些最强大的超级计算机的文件系统。Lustre 文件系统提供符合 POSIX 标准的文件系统接口，可以扩展到数千个客户端、PB 级存储和每秒数百 GB 的 I/O 带宽。Lustre 文件系统的关键组件是元数据服务器 （MDS）、元数据目标 （MDT）、对象存储服务器 （OSS）、对象服务器目标 （OST） 和 Lustre 客户端。</p><img src="/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/LustreComponents21.gif" class="" title="LustreComponents21"><p><a href="http://lustrefs.cn/wp-content/uploads/2023/03/Lustre_Manual_cn.pdf">Lustre_Manual_cn.pdf</a></p><p>Lustre中的角色：</p><ol><li><strong>管理服务器（Management Server, MGS）：</strong></li></ol><p>​    ● 管理整个文件系统的元信息和配置。</p><p>​    ● 硬件要求：高性能 CPU、充足的内存和可靠存储设备。</p><ol><li><strong>元数据服务器（Metadata Server, MDS）：</strong></li></ol><p>​    ● 存储文件系统的元数据（如文件名、目录结构等）。</p><p>​    ● 通常与元数据目标（Metadata Target, MDT）一起部署在 MDS 上。</p><ol><li><strong>对象存储服务器（Object Storage Server, OSS）：</strong></li></ol><p>​    ● 存储文件数据。</p><p>​    ● 每个 OSS 管理一个或多个对象存储目标（Object Storage Target, OST）。</p><ol><li><strong>客户端：</strong></li></ol><p>​    ● 连接并访问 Lustre 文件系统的计算节点</p><p><a href="https://www.hikunpeng.com/document/detail/zh/kunpengsdss/ecosystemEnable/Lustre/openmind_kunpenglustre_04_0002.html">环境要求-Lustre 2.13.0 部署指南（CentOS 8.0）-Lustre-开源使能-开发文档-鲲鹏社区</a>)</p><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><p>参考文档:</p><p><a href="https://note.youdao.com/ynoteshare/index.html?id=113224210bf5120b2731ae9e0af5ebb4&amp;type=note&amp;_time=1734593758030">Lustre 2.10安装.note</a></p><p><a href="https://blog.csdn.net/spring_color/article/details/79301167?ops_request_misc=%7B%22request%5Fid%22%3A%22d9945c8131134fab2ed7eff447d79e82%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=d9945c8131134fab2ed7eff447d79e82&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-79301167-null-null.142^v100^pc_search_result_base3&amp;utm_term=Lustre部署·centos7&amp;spm=1018.2226.3001.4187">CentOS-7 安装Lustre-2.10.1文件系统_centos7安装lustre-CSDN博客</a></p><div class="table-container"><table><thead><tr><th>节点名</th><th>节点IP</th><th>节点角色</th><th>软件版本</th></tr></thead><tbody><tr><td>cn17538</td><td>10.182.190.3</td><td>MDS、MDT、OST</td><td>系统版本：centos7.3</td></tr><tr><td>cn17539</td><td>10.182.190.4</td><td>MDT、OST</td><td>软件版本：7.2.4-el7</td></tr><tr><td>cn17540</td><td>10.182.190.5</td><td>Client</td></tr></tbody></table></div><h3 id="简单配置Linux"><a href="#简单配置Linux" class="headerlink" title="简单配置Linux"></a>简单配置Linux</h3><p>1、更新yum源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum clean all</span><br><span class="line">$ yum makecache</span><br><span class="line">$ yum update</span><br></pre></td></tr></table></figure><p>2、 安装基础包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum groupinstall <span class="string">&quot;Development Tools&quot;</span> -y</span><br><span class="line">$ yum install epel-release quilt libselinux-devel python-docutils xmlto asciidoc elfutils-libelf-devel elfutils-devel zlib-devel rng-tools binutils-devel python-devel sg3_utils newt-devel perl-ExtUtils-Embed audit-libs-devel lsof hmaccalc -y</span><br></pre></td></tr></table></figure><p>3、关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld.service</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure><h3 id="构建本地Lustre-repo库"><a href="#构建本地Lustre-repo库" class="headerlink" title="构建本地Lustre repo库"></a>构建本地Lustre repo库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/yum.repos.d/lustre.repo</span><br></pre></td></tr></table></figure><p>在lustre.repo里写入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[lustre-server]</span><br><span class="line">name=lustre-server</span><br><span class="line">baseurl=https://downloads.whamcloud.com/public/lustre/latest-2.10-release/el7/server</span><br><span class="line"><span class="comment"># exclude=*debuginfo*</span></span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">[lustre-client]</span><br><span class="line">name=lustre-client</span><br><span class="line">baseurl=https://downloads.whamcloud.com/public/lustre/latest-2.10-release/el7/client</span><br><span class="line"><span class="comment"># exclude=*debuginfo*</span></span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">[e2fsprogs-wc]</span><br><span class="line">name=e2fsprogs-wc</span><br><span class="line">baseurl=https://downloads.whamcloud.com/public/e2fsprogs/latest/el7</span><br><span class="line"><span class="comment"># exclude=*debuginfo*</span></span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>更新源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum clean all </span><br><span class="line">$ yum makecache</span><br></pre></td></tr></table></figure><p>参考文档出现如下出现问题：</p><img src="/2025/02/20/centos7-3%E9%83%A8%E7%BD%B2lustre2-10-8/image-20250225215515963.png" class="" title="image-20250225215515963"><p>解决问题：参考文档中这一部分操作写了一堆，我也看不懂，不知道什么原因，我直接在/etc/yum.repos.d中创建了lustre.repo文件，并更新了yum源，似乎没什么问题</p><h2 id="服务节点安装（MDS、OSS）"><a href="#服务节点安装（MDS、OSS）" class="headerlink" title="服务节点安装（MDS、OSS）"></a>服务节点安装（MDS、OSS）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ yum --nogpgcheck --disablerepo=* --enablerepo=e2fsprogs-wc install e2fsprogs -y</span><br><span class="line">$ yum -y install epel-release</span><br><span class="line">$ yum install http://download.zfsonlinux.org/epel/zfs-release.el7_3.noarch.rpm -y</span><br><span class="line">$ yum upgrade linux-firmware dracut -y <span class="comment"># 升级冲突包</span></span><br><span class="line">$ yum upgrade xfsprogs kmod kexec-tools -y <span class="comment"># 升级冲突包</span></span><br><span class="line">$ yum install pciutils -y</span><br><span class="line">$ yum --nogpgcheck --disablerepo=base,extras,updates --enablerepo=lustre-server install kernel kernel-devel kernel-headers kernel-tools kernel-tools-libs kernel-tools-libs-devel -y</span><br><span class="line">$ reboot</span><br><span class="line">$ yum --nogpgcheck --enablerepo=lustre-server install kmod-lustre-osd-ldiskfs lustre-dkms lustre-osd-ldiskfs-mount lustre lustre-resource-agents zfs lustre-osd-zfs-mount -y</span><br><span class="line"></span><br><span class="line">加载 ZFS 文件系统的内核模块</span><br><span class="line">$ modprobe -v zfs</span><br><span class="line">加载 Lustre 文件系统的内核模块</span><br><span class="line">$ modprobe -v lustre</span><br></pre></td></tr></table></figure><p>服务节点安装的是2.10.8版本，客户端安装2.10.8版本时发现，centos默认的内核不支持客户端安装2.10.8版本，所以客户端安装的是2.10.1版本。</p><h1 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a><strong>客户端安装</strong></h1><p>最好不要和MDS和ODS安装在一个节点上，会出现内核不兼容的问题，如果出现安装的客户端与默认的系统内核不兼容的问题，可以尝试更换系统中其他的内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum install kernel kernel-devel kernel-headers kernel-abi-whitelists kernel-tools kernel-tools-libs kernel-tools-libs-devel -y</span><br><span class="line">$ reboot</span><br><span class="line">$ yum install epel-release -y</span><br><span class="line">$ yum --nogpgcheck --enablerepo=lustre-client install lustre-client-dkms lustre-client kmod-lustre-client -y</span><br></pre></td></tr></table></figure><p>切换内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看当前系统可用内核</span><br><span class="line">$ <span class="built_in">sudo</span> awk -F\&#x27; <span class="string">&#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27;</span> /etc/grub2.cfg</span><br><span class="line">选择输出的内核编号</span><br><span class="line">$  <span class="built_in">sudo</span> grub2-set-default <span class="string">&#x27;1&#x27;</span></span><br><span class="line">$ reboot</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h1><p>​     Lustre是基于内核的分布式文件系统，而不是像其它一些用户态的分布式文件系统那样直接建立在ext3或者是ext4之上。Lustre需要对磁盘进行格式化，并且在格式化的过程中进行参数配置。</p><p>​    在 Lustre 中，MGS（Management Server） 是一个集中式的元数据服务，它负责管理整个 Lustre 文件系统的元数据。MGS 通常只在第一个 MDT 节点上配置，并且该节点会作为主 MDT 来管理所有的元数据操作。一旦配置了 MGS，Lustre 文件系统的所有 MDT节点会通过网络连接到该 MGS。因为 MGS 是唯一的，它的作用是服务所有 MDT 节点（无论你有多少个 MDT 节点）</p><h3 id="配置MDT"><a href="#配置MDT" class="headerlink" title="配置MDT"></a>配置MDT</h3><p>通过—index来对每个MDT进行标识</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、配置第一个MDS</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgs --mdt --index=0 /dev/nvme0n1p3</span><br><span class="line"> $ <span class="built_in">mkdir</span> /mnt/lustre/mdt</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p3 /mnt/lustre/mdt</span><br><span class="line"></span><br><span class="line">2、配置第二个MDS</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgsnode=10.182.190.3@tcp0 --mdt --index=1 /dev/nvme0n1p3</span><br><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre/mdt</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p3 /mnt/lustre/mdt</span><br><span class="line"> </span><br><span class="line">参数解释： </span><br><span class="line">fsname指定的是创建lustre时的文件系统名 </span><br><span class="line">mgs指定该机器为元数据服务器，即该机器为mds </span><br><span class="line">mdt指定/dev/sdb为元数据实际数据存储位置 </span><br><span class="line">至于index则指定该mgs的索引号，mgs可以设置主备模式，但mdt需要在主备mds之间共享 </span><br></pre></td></tr></table></figure><h3 id="配置OST"><a href="#配置OST" class="headerlink" title="配置OST"></a>配置OST</h3><p>通过—index来对每个OST进行标识</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、配置第一个OST</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgsnode=10.182.190.3@tcp0 --ost --index=0 /dev/nvme0n1p2</span><br><span class="line">查看是否格式化成功</span><br><span class="line">$ <span class="built_in">sudo</span> lsblk -f</span><br><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre/ost</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p2 /mnt/lustre/ost</span><br><span class="line"></span><br><span class="line">2、配置第二个OST</span><br><span class="line">$ mkfs.lustre --reformat --fsname=lustrefs --mgsnode=10.182.190.3@tcp0 --ost --index=1 /dev/nvme0n1p2</span><br><span class="line">查看是否格式化成功</span><br><span class="line">$ <span class="built_in">sudo</span> lsblk -f</span><br><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre/ost</span><br><span class="line">$ mount -t lustre /dev/nvme0n1p2 /mnt/lustre/ost</span><br></pre></td></tr></table></figure><h3 id="配置Client"><a href="#配置Client" class="headerlink" title="配置Client"></a>配置Client</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> /mnt/lustre</span><br><span class="line">$ mount -t lustre 10.182.190.3@tcp:/lustrefs /mnt/lustre</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ToolGuide </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/2025/02/19/Compilation-Principle/"/>
      <url>/2025/02/19/Compilation-Principle/</url>
      
        <content type="html"><![CDATA[<p>​    程序设计语言是向人以及计算机描述计算过程的记号。例如我们所知道的这个世界依赖于程序设计语言，因为在所有计算机上运行的所有软件都是用某种程序设计语言编写的。但是，在一个程序可以运行之前，它首先需要被翻译成一种能够被计算机执行的形式，完成这项翻译工作的软件系统就是编译器。编译器可以将某种语言(源语言)编写的程序翻译成一个等价的用另外一种语言编写的程序。</p><p>​    编译器能够把源程序映射为语义上等价的目标程序，这个过程可以由两部分组成: 分析部分和综合部分；</p><ul><li>分析部分(前端)：把源程序分解成为多个组成要素，并在这些要素之上加上语法结构。然后使用这个结构来创建该源程序的一个中间表示。如果分析部分检查出源程序没有按照正确的语法构成，或者语义上不一致，它就必须提供有用的信息，使得用户可以按此进行改正。分析部分还会收集有关源程序的信息，并把信息存放在一个称为符号表的数据结构中。符号表将和中间表示形式一起传送给综合部分。</li><li>综合部分(后端)：根据中间表示和符号表中的信息来构造用户期待的目标程序。</li></ul><p>编译过程中顺序的执行了一组步骤。每个步骤把源程序的一种表示方式转换为另一种表示方式。如下图所示</p><img src="/2025/02/19/Compilation-Principle/image-20250222145903286.png" class="" title="image-20250222145903286"><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>源程序—&gt; <strong>词法分析器</strong> —&gt;记号流(token)—&gt; <strong>语法分析器</strong> —&gt;抽象语法树—&gt; <strong>语义分析器</strong> —&gt;中间表示IR</p><img src="/2025/02/19/Compilation-Principle/image-20250222124616749.png" class="" title="image-20250222124616749"><h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p>两种实现方式：</p><ul><li>手动编码，GCC、LLVM，转移图算法</li><li>词法生成器自动生成器(lex/flex/jlex)</li></ul><p>RE—&gt;NFA—&gt;DFA—&gt;词法分析器代码<br>中间算法：Thompson算法—子集构造算法—Hopcroft最小化算法</p><h3 id="正则表达式RE"><a href="#正则表达式RE" class="headerlink" title="正则表达式RE"></a>正则表达式RE</h3><p>声明式规范(正则表达式)—&gt;词法分析器<br>对于给定的字符集 $\Sigma = {c1,c2,…,cn}$<br>归纳定义：</p><ul><li>空串是正则表达式</li><li>对于任意的 <script type="math/tex">c\in\Sigma</script>，c是正则表达式</li><li>如果M和N是正则表达式，则以下也是正则表达式<ul><li>选择  M|N = {M, N}</li><li>连接  MM = {mn| m <script type="math/tex">\in</script> M, n <script type="math/tex">\in</script> N }</li><li>闭包  M* = { $\varepsilon$, M, MM, MMM, … }</li></ul></li></ul><h3 id="有限状态自动机FA"><a href="#有限状态自动机FA" class="headerlink" title="有限状态自动机FA"></a>有限状态自动机FA</h3><p>输入的字符串—&gt;FA—&gt;{yes, no} 什么样的串可以被接受</p><ul><li>确定状态有限自动机DFA<ul><li>对任意的字符，最多有一个状态可以转移</li></ul></li><li>非确定状态有限自动机NFA<ul><li>对任意的字符，有多个状态可以转移</li></ul></li></ul><h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>记号流(token)—&gt; <strong>语法分析器</strong> (语言的语法规则) —&gt; 语法树<br>语法规则：<br>上下文无关文法的定义：</p><ul><li>上下文无关文法(简称 <strong>文法</strong> )由终结符号、非终结符号、一个开始符号和一组产生式组成</li><li>终结符号是组成串的基本符号</li><li>非终结符号是表示串的集合的语法变量</li><li>某个非终结符号被指定为开始符号，这个符号表示的串集合就是这个文法生成的语言。按照惯例，首先列出来开始符号的产生式。</li><li>一个文法的产生式描述了将终结符号和非终结符号组合成串的方法。每个产生式由下列形式组成：<blockquote><p>非终结符号 —→ 零个或者多个终结符号与非终结符号组成<br>selection_statement<br>: IF ‘(‘ expression ‘)’ statement<br>| IF ‘(‘ expression ‘)’ statement ELSE statement;<br>|<br>;</p></blockquote></li></ul><p>语法分析树：过滤掉了推导过程中对非终结符号应用产生式的顺序。语法分析树的每个内部节点表示一个产生式的应用。该内部节点表示一个产生式的应用。该内部节点的标号是此产生式头中的非终结符号A；这个节点的子节点的标号从左到右组成了在推导过程中替换这个A的产生式体。</p><p>二义性：如果一个文法可以为某个句子生成多棵语法分析树，那么它就是二义性的；换句话说，二义性文法就是对同一个句子有多个最左推导或多个最右推导的文法。<br>解决方法：文法的重写</p><p>语法分析器的实现方式</p><ul><li>手工分析—递归下降分析器</li><li>自动生成器—LL(1)、LR(1)</li></ul><h3 id="自顶向下分析：从开始符号出发推导句子"><a href="#自顶向下分析：从开始符号出发推导句子" class="headerlink" title="自顶向下分析：从开始符号出发推导句子"></a>自顶向下分析：从开始符号出发推导句子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tokens[];</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">stack = [s];</span><br><span class="line"><span class="keyword">while</span> ( stack != [] )</span><br><span class="line">    <span class="keyword">if</span> ( stack[top] is a terminal t)</span><br><span class="line">        <span class="keyword">if</span> ( t==tokens[i++] )</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">backtrack</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( stack[top] is a nonterminal T )</span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">push</span>( the next right hand side of T );</span><br></pre></td></tr></table></figure><p>需要通道回溯，给分析效率带来问题；实际上编译器必须高效，需要线性时间的算法，因此引出递归下降分析和LL(1)分析；</p><p>递归下降分析算法(预测分析)</p><ul><li>每个非终结符构造一个分析函数；</li><li>用前看符号指导产生式规则的选择。</li></ul><p>自动生成<br>声明式的规范—&gt;自动生成器(antlr:LL(1)、YACC(Unix)、bison(linux))—&gt;语法分析器<br>LL(1)分析算法</p><ul><li>从左(L)向右读入程序，最左(L)推导，采用一个(1)前看符号<ul><li>分析高效(线性时间)</li><li>错误定位和诊断信息准确</li><li>有很多开源或商业的生成工具(antlr)</li></ul></li><li>基本思想：表驱动的分析算法</li><li>缺点  <ul><li>能分析的文法类型受限</li><li>往往需要文法的改写</li></ul></li></ul><h3 id="自底向上分析"><a href="#自底向上分析" class="headerlink" title="自底向上分析"></a>自底向上分析</h3><p>LR分析算法(移进-规约算法)</p><ul><li>算法运行高效，有现成的工具可用</li><li>目前最广泛的一类语法分析器的自动生成器(YACC,bison,CUP,C#yacc等)中采用的算法</li><li>移进 一个记号到栈顶上，或者</li><li>规约 栈顶上的n个符号(某产生式的右部)到左部的非终结符<ul><li>对产生式A —&gt; $\beta 1…\beta n$<ul><li>如果 $\beta n…\beta 1$在栈顶上，则弹出 $\beta n…\beta 1$ ，压入A</li></ul></li></ul></li><li>表驱动的LR分析器架构<br>点记号：为了方便标记语法分析器已经读入了多少输入，我们可以引入一个点记号；</li></ul><p>LR(0)分析算法</p><ul><li>从左(L)向右读入程序，最右(R)推导，不用前看符号来决定式的选择(0个前看符号)<ul><li>优点：容易实现</li><li>缺点：能分析的文法有限</li></ul></li></ul><p>SLR分析算法</p><ul><li>和LR(0)分析算法基本步骤相同</li><li>仅区别于对归约的处理<ul><li>对于状态i上的项目X-&gt; $\alpha ·$, 仅对y $\in$ FOLLOW(X)添加ACTION[i,y]</li></ul></li></ul><p>LR(1)分析算法</p><ul><li>基于LR(0),通过进一步判断一个前看符号，来决定是否执行规约动作<ul><li>X—&gt; $\alpha ·$归约，当且仅当y $\in$ FOLLOW(X)</li></ul></li><li>优点<ul><li>有可能减少需要归约的情况</li><li>有可能去除需要递进-归约冲突</li></ul></li><li>缺点<ul><li>仍然有冲突出现的可能</li></ul></li></ul><p>对二义性文法的处理</p><ul><li>二义性文法无法使用LR分析算法分析</li><li>有几类二义性文法很容易理解：优先级、结合性、悬空else</li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>YACC是Yet Another Compiler-Compiler缩写，在1975年首先在此基础上做了改进：例如GNU Bison，并移植到其他语言上<br>Yacc架构</p><blockquote><p>用户代码和yacc声明：可以再接下来的部分使用<br>%%<br>语法规则：上下文无关文法<br>%%<br>用户代码：用户提供的代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">yylex</span><span class="params">()</span></span>;<span class="comment">//词法分析器的接口</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%left <span class="string">&#x27;+&#x27;</span></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">exp : n</span><br><span class="line">    | exp + exp</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">n: <span class="string">&#x27;1&#x27;</span>| <span class="string">&#x27;2&#x27;</span> | <span class="string">&#x27;3&#x27;</span> |;</span><br><span class="line">%%</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">yylex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">char</span>* s)</span></span>&#123;</span><br><span class="line">   <span class="built_in">fprintf</span> (stderr, <span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">yyparse</span>(); <span class="comment">// 语法分析器的驱动函数；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法制导的翻译"><a href="#语法制导的翻译" class="headerlink" title="语法制导的翻译"></a>语法制导的翻译</h3><p>编译器在做语法分析的过程中，除了回答程序语法是否合法外，还必须完成后续工作</p><ul><li>可能得工作(包括但不限于)：类型检查、目标代码生成、中间代码生成。这些后续的工作一般可通过语法制导的翻译完成；</li><li>给每条产生式规则附加一条语义动作(一个代码片段)</li><li>语义动作产生式”归约”时执行，即由右部的值计算左部的值，以自底向上的技术为例进行讨论</li></ul><h3 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h3><p><style>.hygurlvdhtqe{zoom: 40%;}</style><img src="/2025/02/19/Compilation-Principle/image.png" class="hygurlvdhtqe" alt="image"><br>对于表达书而言，编译器只需要知道运算符和运算符(优先级、结合性等已经在语法分析部分处理掉了)。对于语句、函数等语言其他构造而言也一样(例如编译器不关心赋值符号是=还是:=或其他)s</p><ul><li>具体语法是语法分析器使用的语法<ul><li>必须适合于语法分析，如各种分隔符、消除左递归、提取左公因子等；</li></ul></li><li>抽象语法是用来表达语法结构的内部表示<ul><li>现代编译器一般都采用 <strong>抽象语法作为前端(词法语法分析)和后端(代码生成)的接口</strong><ul><li>程序一旦被转换为抽象语法树，则源代码即被丢弃，后续阶段只处理抽象语法树</li><li>所以抽象语法书必须编码足够多的源代码信息，例如：必须编码每个语法结构在源代码中的位置(文件、行号、列号等)</li></ul></li><li>为了定义抽象语法树，编译器需要使用实现语言来定义一组数据结构</li></ul></li></ul><h2 id="语义分析器"><a href="#语义分析器" class="headerlink" title="语义分析器"></a>语义分析器</h2><p>语义分析也称为类型检查、<strong>上下文相关分析</strong>，负责检查程序(抽象语法树)的上下文相关的属性:例如，变量使用前先进行声明、每个表达式都有合适的类型、函数调用和函数的定义一致。</p><p>抽象语法树—&gt;语义分析器(根据程序语言的语义进行判断)—&gt;中间代码</p><p>语义检查</p><p>符号表: 用来存储程序中的变量相关信息(类型、作用域、访问控制信息，处理名字空间)、应为程序中的变量规模会风大，所以必须非常高效，可以使用哈希表(节省时间、O(1)时间)、红黑树(节省空间、O(lgN)时间)等数据结构来实现。</p><p>语义分析：类型相容性、错误诊断、代码翻译</p><h1 id="中间端和后端"><a href="#中间端和后端" class="headerlink" title="中间端和后端"></a>中间端和后端</h1><p>抽象语法树—&gt;代码生成(翻译1—&gt;中间表示1—&gt;翻译2—&gt;中间表示2—&gt;更多的翻译和中间表示)—&gt;汇编</p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>负责把源程序翻译成”目标机器”上的代码，两个重要任务:</p><ul><li>给源程序的数据分配计算资源<ul><li>源程序的数据：全局变量、局部变量、动态分配等</li><li>机器计算资源：寄存器、数据区、代码区、栈区、堆区</li><li>根据程序的特点和编译器的设计目标，合理的为数据分配计算机资源，例如：变量放在内存里还是寄存器里？</li></ul></li><li>给源程序的代码选择指令<ul><li>源程序的代码：表达式运算、语句、函数等</li><li>机器指令：算术运算、比较、跳转、函数调用返回</li><li>用机器指令实现高层代码的语义：等价性、对机器指令集体系结构(ISA的熟悉)</li></ul></li></ul><p>两种不同的ISA上的代码生成技术</p><ul><li>栈计算机stack<ul><li>历史：在上世纪70年代有很多的栈式计算机，但是因为效率低下已经逐渐退出历史舞台；</li><li>给栈式计算机生产代码是最容易的；</li><li>仍然有很多栈式的虚拟机：Pascal P code、java virtual machine(JVM)…..</li></ul></li><li>寄存器计算机Reg<ul><li>寄存器计算机是目前最流行的机器体系结构之一，效率很高，机器体系结构规整</li><li>机器基于寄存器架构：<ul><li>经典的有16、32或更多个寄存器，所有操作都在寄存器中进行</li><li>访存都通过load/store进行，内存不能直接运算</li></ul></li></ul></li></ul><h2 id="中间代码的地位和作用"><a href="#中间代码的地位和作用" class="headerlink" title="中间代码的地位和作用"></a>中间代码的地位和作用</h2><p>为什么划分不同的中间表示？</p><p>编译器工程上的考虑</p><ul><li>阶段划分：把整个编译过程划分为不同的阶段</li><li>任务分解：每个阶段只处理翻译过程的一个步骤</li><li>代码工程：代码更容易实现、出错、维护和演进</li></ul><p>程序分析和代码优化的需求：两者都和程序的中间表示密切相关，许多优化在特定的中间表示上才可以或才容易进行；</p><p>现代编译器中几种常见的重要中间表示(Intermediate Representation，IR)：三地址码、控制流图、静态单赋值形式；</p><p>在中间表示上做程序分析的理论和技术：控制流分析、数据流分析</p><ul><li><h5 id="三地址码"><a href="#三地址码" class="headerlink" title="三地址码"></a>三地址码</h5><ul><li><p><strong>每条指令有三项操作数</strong>，因此叫做三地址码。每条指令通常会有一个目标地址（存储结果的变量或临时变量），以及两个源地址（操作数）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y op z</span><br></pre></td></tr></table></figure></li><li><p>给每个中间变量和计算结果命名后没有复合表达式</p></li><li><p>只有最基本的控制流，没有各种控制结构(if、do、for…)，只有goto、call等</p></li><li><p>所以三地址码可以看成是抽象的指令集，可以看成是一个通用的RISC</p></li><li><p>程序的控制流信息是隐式的，可以做进一步的控制流分析</p><p><style>.oqtnahykywsy{zoom:80%;}</style><img src="/2025/02/19/Compilation-Principle/image-20250221171039051.png" class="oqtnahykywsy" alt="image-20250221171039051"></p></li></ul></li><li><h5 id="控制流分析"><a href="#控制流分析" class="headerlink" title="控制流分析"></a>控制流分析</h5><ul><li><p>是更加精细的三地址码</p></li><li><p>程序的控制流图表示带来了很多好处</p><ul><li>控制流分析：对于很多程序分析来说，程序的内部结构很重要；经典问题：程序中是否存在循环？</li><li>可以进一步进行其他分析：例如数据流分析；经典问题：程序第5行的变量x可能的值是什么？</li></ul><img src="/2025/02/19/Compilation-Principle/image-20250221205441500.png" class="" title="image-20250221205441500"></li><li><p>现代编译器的早期阶段就会倾向于做控制流分析，方便后续阶段的分析</p></li><li><p>基本块：是一个语句的序列，从第一条执行到最后一条，不能从中间进入和退出(即跳转指令只能出现在最后)</p></li><li><p>控制流图：控制流图是一个有向图G=(V,E)；节点V是基本块，边E是基本块之间的跳转关系</p><img src="/2025/02/19/Compilation-Principle/image-20250221193740043.png" class="" title="image-20250221193740043"></li><li><p>可以直接从抽象语法树生成：如果高层语言具有特别规整控制流结构的话较容易；也可以先生成三地址码，然后继续生成控制流图：</p><ul><li>对于像C这样的语言更加合适，包含像goto这样的非结构化的控制流语句；</li><li>更加通用(阶段划分)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List_t stms;               <span class="comment">// 三地址码中所有语句</span></span><br><span class="line">List_t blocks = &#123;&#125;；       <span class="comment">//控制流图中的所有基本块</span></span><br><span class="line">Block_t b = <span class="built_in">Block_fresh</span>();   <span class="comment">//一个初始的空的基本块</span></span><br><span class="line"><span class="built_in">scan_stms</span>()</span><br><span class="line">    foreach(s in stms)</span><br><span class="line">    <span class="keyword">if</span> (s is <span class="string">&quot;Label L&quot;</span>)    <span class="comment">// s是标号</span></span><br><span class="line">            b.label = L;</span><br><span class="line"><span class="keyword">else</span> (s is some jump)  <span class="comment">//s是跳转</span></span><br><span class="line">            b.j = s;</span><br><span class="line">blocks U= &#123;b&#125;;</span><br><span class="line">b = <span class="built_in">Block_fresh</span>();</span><br><span class="line"><span class="keyword">else</span>                 <span class="comment">// s是普通指令</span></span><br><span class="line">            b.stms U= &#123;s&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>标准的图论算法都可以用在控制流图的操作上：各种遍历算法、生成树、必经节点结构等等；</li><li>图节点的顺序有重要的应用：拓扑序、逆拓扑序、近似拓扑序等等；</li></ul><ul><li><h5 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h5><ul><li>常量传播优化</li><li>通过对程序代码进行静态分析，得到关于程序数据相关的保守信息，必须保证程序分析的结果是安全的</li><li>根据优化的目标不同，需要进行的数据流分析也不同<ul><li><strong>到达定义分析</strong>：对每个变量的使用点，有哪些定义可以到达？(即该变量的值是在哪儿赋值的)<ul><li>数据流方程</li></ul></li><li><strong>活性分析</strong>：在代码生成的讨论中，机器只有有限多个寄存器，寄存器分配优化需要进行活性分析</li></ul></li></ul></li></ul><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>代码优化是对被优化的程序进行的一种语义保持(程序的可观察行为不能改变)的变换，变换的目的是让程序能够比变换前更小、更快、cache行为更好、更节能等等；</p><h5 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h5><ul><li><p>一般在抽象语法树阶段做优化</p></li><li><p>局部的、流不敏感的</p></li><li><p>常量折叠、代数优化、死代码删除等</p><ul><li><p>常量折叠：在编译期间计算表达式的值，可以在整型、布尔型、浮点型等数据类型上进行；容易实现、可以在语法树或者中间表示上进行，通常被实现成公共子函数被其他优化调用；</p><blockquote><p>例如：a=3+5 ==&gt; a=8</p><p>例如：if(true&amp;&amp;false) ==&gt;if(false)</p><p>必须要很小心遵守语言的语义，例如：考虑溢出或异常  oxffffffff+1==&gt;0 ???</p></blockquote></li><li><p>代数化简：利用代数系统的性质对程序进行化简</p><blockquote><p>示例：</p><p>a = 0+b ==&gt; a = b</p><p>a = 1*b ==&gt; a = b</p><p>2*a ==&gt; a + a          （强度削弱）</p><p>2*a ==&gt; a&lt;&lt;1             (强度削弱)</p><p>同样必须非常仔细的处理语义，例如：(i - j) + (i - j) ==&gt; i + i - j - j</p></blockquote></li><li><p>死代码(不可达代码)删除：静态移除程序中不可执行的代码</p><blockquote><p>示例:</p><p>if (false)</p><p>​       s1;</p><p>else s2;       ==&gt; s2;</p><p>在控制流图中也可以进行这些优化，但在早期做这些优化可以简单中后端</p></blockquote></li></ul></li></ul><h5 id="中期优化"><a href="#中期优化" class="headerlink" title="中期优化"></a>中期优化</h5><ul><li><p>在中间表示上进行代码优化</p></li><li><p>全局的、流敏感的</p></li><li><p>依赖于具体所使用的中间表示：</p><ul><li><p>控制流图(CFG)、控制依赖图(CDG)、静态单赋值形式(SSA)、后续传递风格(CPS)等</p></li><li><p>共同的特点是需要进行程序分析，优化是全局进行的，而不是局部，通用的模式是：程序分析—&gt;程序重写</p></li><li><p>优化的一般模式: </p><img src="/2025/02/19/Compilation-Principle/image-20250222141611890.png" class="" title="image-20250222141611890"></li></ul></li><li><p>常量传播、拷贝传播、死代码删除、公共字表达式删除等</p><ul><li><p>常量传播：先进行到达定义分析,例如x=1,y=2,z=x+y —&gt; x=1,y=2,z=3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量传播算法</span></span><br><span class="line"><span class="built_in">const_prop</span>(Prog_t p)</span><br><span class="line">    <span class="comment">//第一个：程序分析</span></span><br><span class="line">    <span class="built_in">reaching_definition</span>(p)</span><br><span class="line">    <span class="comment">//第二步：程序改写</span></span><br><span class="line">    foreach(stm s in p: y = x1,...,xn)</span><br><span class="line">    foreach(use of xi in s)</span><br><span class="line">    <span class="keyword">if</span>(the reaching def of xi is unique: xi = n )</span><br><span class="line">                y = x1,...,xi<span class="number">-1</span>,n,xi<span class="number">+1</span>,...,xn</span><br></pre></td></tr></table></figure></li><li><p>拷贝传播: 例如: x=y ;a=x —&gt; a=y</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量传播算法</span></span><br><span class="line"><span class="built_in">const_prop</span>(Prog_t p)</span><br><span class="line">    <span class="comment">//第一个：程序分析</span></span><br><span class="line">    <span class="built_in">reaching_definition</span>(p)</span><br><span class="line">    <span class="comment">//第二步：程序改写</span></span><br><span class="line">    foreach(stm s in p: y = x1,...,xn)</span><br><span class="line">    foreach(use of xi in s)</span><br><span class="line">    <span class="keyword">if</span>(the reaching def of xi is unique: xi = z )</span><br><span class="line">                y = x1,...,xi<span class="number">-1</span>,z,xi<span class="number">+1</span>,...,xn</span><br></pre></td></tr></table></figure></li><li><p>死代码删除：需要进行活性分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//死代码删除算法</span></span><br><span class="line"><span class="built_in">dead_code</span>(Prog_t p)</span><br><span class="line">    <span class="comment">//第一步：程序分析</span></span><br><span class="line">    <span class="built_in">liveness_analysis</span>(p);</span><br><span class="line"><span class="comment">//第二步：程序改写</span></span><br><span class="line">foreach(stm s in p:y = ...)</span><br><span class="line">        <span class="keyword">if</span>(y is NOT in live_out[s])</span><br><span class="line">            <span class="built_in">remove</span>(s);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h5><ul><li>在后端(汇编代码级)进行</li><li>寄存器分配、指令调度、窥孔优化等</li></ul><h1 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a><strong>Reflection</strong></h1><p>OS：终于把本科分流后欠下的债还了一部分了。谁懂啊，从计算机专业分流去了大数据后，研究生阶段又跑来搞系统；</p><p>参考资源：</p><p>网课：<a href="https://www.bilibili.com/video/BV17W41187gL?spm_id_from=333.788.videopod.episodes&amp;vd_source=93e39300d281cef5ad42ab13d4028d04">编译原理 — 中科大_哔哩哔哩_bilibili</a></p><p>书籍：<a href="https://gitee.com/Microservice-Framework/E-book.git">编译原理(原书第2版)(龙书) .pdf · 曾彩军/E-book - Gitee.com</a></p>]]></content>
      
      
      <categories>
          
          <category> CS基础 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
